<h0>Getting Started</h0><section><h3>Introduction</h3>

<p>The Computer Science handbook is a handbook designed to explain algorithms and data structures in a way that anyone can understand. Many websites (eg Wikipedia) contain lengthy and wordy explanations that are full of technical jargon. We have tried our hardest to simplify all language to make it easy to read without any math or computer science background. We hope to share our knowledge with you and we ask only one thing from you. You must learn something before you leave!</p>

</section><h0>Fundamentals</h0><section><h3>Introduction</h3>

<p>There are some fundamental topics about writing computer programs that we must learn before we can move on to the basic theory.</p>

</section><h1>Data Types</h1><section><h2>Introduction</h2>

<p>We use closets or drawers to store our clothes and garages to store our cars. Similarly, we store different types of data in different kinds of data types. Most programming languages will support these data types and picking the right data type is important.</p>

<p>To define a variable of a data type we use the follow syntax:</p>

<p><strong>datatype</strong> <strong>variable_name</strong> = <strong>init_val</strong>;</p>

<ul>
<li><strong>datatype</strong> is the type of variable</li>
<li><strong>variable_name</strong> is the name of the variable used</li>
<li><strong>init_val</strong> is the initial value of the variable</li>
</ul>

<p>Example:</p>

<pre class="prettyprint linenums ">
int x = 3;
double y = -4.5;
</pre>

<p>x is an integer, and we initialize it with the value 3. y is a double floating point number (essentially a decimal number) and we initialize it with -4.5</p>

</section><section><h2><a href="./Boolean" target="_blank">Boolean</a></h2>

<p>A boolean is stored in a bit that is either true or false. Booleans are usually used as flags to store if something is one one state or the other.</p>

<table>
<thead>
<tr>
  <th>Data type</th>
  <th>Number of bits</th>
  <th>Range</th>
</tr>
</thead>
<tbody>
<tr>
  <td>bool</td>
  <td>2 bits</td>
  <td>true or false</td>
</tr>
</tbody>
</table>

</section><section><h2><a href="./Integer" target="_blank">Integer</a></h2>

<p>An integer is any number that does not contain decimals. It is stored as binary number in memory. For example: 0, -5, 6 are integers.</p>

<table>
<thead>
<tr>
  <th>Data type</th>
  <th>Number of bits</th>
  <th>Range</th>
</tr>
</thead>
<tbody>
<tr>
  <td>byte</td>
  <td>8 bits</td>
  <td>-128 to 127</td>
</tr>
<tr>
  <td>short</td>
  <td>16 bits</td>
  <td>-32,768 to 32,767</td>
</tr>
<tr>
  <td>int</td>
  <td>32 bits</td>
  <td>−2,147,483,648 to 2,147,483,647</td>
</tr>
<tr>
  <td>long</td>
  <td>64 bits</td>
  <td>−9,223,372,036,854,775,808 to 9,223,372,036,854,755,807</td>
</tr>
</tbody>
</table>

</section><section><h2><a href="./Character" target="_blank">Character</a></h2>

<p>A character is any letter or symbol. For example: 'a','B','8','!'.</p>

<p>Characters are usually stored as a number and then displayed as a character by the computer. An encoding is a computer translation from a number to a character. We store simple characters such as lower case and upper case letters, numbers and common punctuation, in 8 bits (0-255) and we can use it to encompass the English language. For these 8 bits, we use an encoding called ASCII. For example: '0' is 48 and 'B' is 66. There are other encodings like Unicode which uses more bits to convert to more languages such as Chinese or Russian. For the most part, we will just use ASCII.</p>

<table>
<thead>
<tr>
  <th>Data type</th>
  <th>Number of bits</th>
  <th>Range</th>
</tr>
</thead>
<tbody>
<tr>
  <td>char</td>
  <td>8 bits</td>
  <td>256 bits</td>
</tr>
</tbody>
</table>

</section><section><h2><a href="./Float" target="_blank">Float</a></h2>

<p>A float is a decimal stored as binary in memory. We use scientific notation to represent the decimal. Scientific notation is a decimal number &lt; 10 times some exponent of 10. For example: 8.23 * 10<sup>4</sup> is in scientific notation. Decimals can be stored in 32 bits or 64 bits.</p>

<p>In a 32bit float, we have 1 bit for the sign (positive or negative), 23 bits for the significant figures (7 digits) and 8 bits for the exponent.</p>

<p>In a 64bit double we have 1 bit for the sign (positive or negative), 52 bits for the significant figures (16 digits) and 11 bits for the exponent.</p>

<table>
<thead>
<tr>
  <th>Data type</th>
  <th>Number of bits</th>
  <th>Range</th>
</tr>
</thead>
<tbody>
<tr>
  <td>float</td>
  <td>32 bits</td>
  <td>3.4e−038 to 3.4e+038</td>
</tr>
<tr>
  <td>double</td>
  <td>64 bits</td>
  <td>1.7e−308 to 1.7e+308</td>
</tr>
</tbody>
</table>
</section><h1>Runtime and Memory</h1><section><h2>Introduction</h2>

<p>Computers are super fast at making calculations compared to humans, but humans have much more "memory" than computers currently do. For example, computers can add two 100-digit numbers together much more quickly than any human possibly can. However, the human brain can contain much more memory than humans.</p>

<p>Brains have trillions of connections between neurons and the estimated storage capacity is about 2.5 petabytes. That is approximately 340 years of TV shows that you could watch! Computers on the other hand, have much less memory than human brains. Standard computers have around 8GB of RAM and some higher end machines may have 16-32GB. Although hard-disks can store terabytes of memory, we use RAM (flash memory) when analyzing computer memory because it is much faster. As an analogy, RAM can be thought of as grabbing an object in another room whereas disk memory is driving 20 min away to get that object.</p>

<p>The neurons and connections in our brains allow us to store an immense amount of information in our brains and allows us to easily recognize patterns much better than computers. For example it is very easy for us to identify different objects around us (e.g. we can easily differentiate between an apple and an orange), but it is difficult for a computer to do this for the countless number of objects in the world. However this is currently changing as more research is being done in "deep learning".</p>

<table>
<thead>
<tr>
  <th></th>
  <th>Brain</th>
  <th>Computer</th>
</tr>
</thead>
<tbody>
<tr>
  <td>Memory</td>
  <td>2.5 petabytes (approx. 340 years of TV shows)</td>
  <td>16GB RAM</td>
</tr>
<tr>
  <td>Processing</td>
  <td>60Hz</td>
  <td>2.7GHz Quad Core (1,000,000,000 times faster than humans)</td>
</tr>
</tbody>
</table>

</section><section><h2>Limits</h2>

<p>There are many different methods of implementing different things but most of the time we care most about implementations that are the fastest and use the least amount of memory. Let's go through some basic benchmarks about computers that you should know. Adding two numbers takes a nanosecond (1 billionth of a second) for an average computer to process. For practical purposes, we'll assume that the average computer program can hold up to 1GB or RAM or about 250 million integers. We use RAM because it is flash memory and read/write is super fast in comparison to disk read/writes.</p>

<table>
<thead>
<tr>
  <th>Memory</th>
  <th>Operations (per seconds)</th>
</tr>
</thead>
<tbody>
<tr>
  <td>1 GB (250,000,000 ints)</td>
  <td>100,000,000 operations</td>
</tr>
</tbody>
</table>

</section><section><h2>Big O Notation</h2>

<p>When we compare how efficient algorithms or data structures are to another, we want to be able to describe them such that they can be quantified. We use something called Big O notation to do this. Many algorithms and data structures will have its time and space complexities depend on the size of the inputs. The Big O notation takes the largest factor of an input to compare computation times / memory usage. When we take the largest factor, we ignore smaller factors, coefficients and constants because they do not matter at very large values. For example: O(3n<sup>2</sup> + 12n + 20) is simply O(n<sup>2</sup>) because it is the largest factor.</p>

<p>Here is a list of common Big O notations based on complexity:</p>

<table>
<thead>
<tr>
  <th>Big O</th>
  <th>Limit of N for 1 second (Standard processor)</th>
</tr>
</thead>
<tbody>
<tr>
  <td>O(1) <em>Constant Time</em></td>
  <td>runtime independent of N</td>
</tr>
<tr>
  <td>O(log N) <em>Sublinear time</em></td>
  <td>a very big number</td>
</tr>
<tr>
  <td>O(N) <em>Linear Time</em></td>
  <td>100,000,000</td>
</tr>
<tr>
  <td>O(N log N)</td>
  <td>5,000,000</td>
</tr>
<tr>
  <td>O(N<sup>2</sup>) <em>Quadractic Time</em></td>
  <td>10000</td>
</tr>
<tr>
  <td>O(N<sup>3</sup>) <em>Cubic Time</em></td>
  <td>450</td>
</tr>
<tr>
  <td>O(2<sup>N</sup>) <em>Exponential Time</em></td>
  <td>27</td>
</tr>
<tr>
  <td>O(N!) <em>Factorial Time</em></td>
  <td>11</td>
</tr>
</tbody>
</table>

<p>Keep in mind that in a couple of years as technology improves, this chart will be outdated.</p>

</section><section><h2>Runtime Analysis</h2>

<p>Let us examine a function that takes in an array of size N and returns the maximum element. In a program we are usually concerned with two complexities: memory and time.</p>

<p>Code:</p>

<pre class="prettyprint linenums ">
int findMax(int[] array){
  int maxVal = array[0]; //O(1) memory to store max element, O(1) time for assignment
  for(int i=1;i&lt;array.length;i++){ //O(n) loop runtime
      if(maxVal &lt; array[i]){ //O(1) to compare runtime
         maxVal = array[i]; //O(1) to assign new value runtime
     }
  }
}
</pre>

<p>Memory: The array takes O(N) memory and storing the max value is O(1) more memory. but usually when analyzing programs, we ignore the input memory sizes and take into account additional memory that is required to produce the output. So the memory footprint of the function is O(1).</p>

<p>Time: The first assignment of maxVal takes O(1). The loop runs N-1 times and of each of those N-1 times it checks if the current array element is greater than the current max which takes O(1). If it is greater, then we reassign maxVal which is O(1). When analyzing time complexity, we usually take worst case so we have: O(1+(N-1)(2)) and this simplifies to O(N) since it is the largest factor.</p>

<hr><h3>Example</h3>

<pre class="prettyprint linenums ">
void zeroArrays(int[][] grid){
  for(int i=0; i&lt;grid.length;i++){
    for(int j=0;j&lt;grid[i].length;j++){
      grid[i][j] = 0;
    }
  }
}
</pre>
</section><h0>Recursion</h0><section><h3>Introduction</h3>

<p><strong>Next</strong>: <a href="./Advanced_Recursion" target="_blank">Advanced Recursion</a></p>

<p>Recursion is process that repeats itself in a similar way. Anything that has its definition nested inside itself is considered to be recursive. For example GNU stands for GNU not Unix!. Expanding this acronym gives us ((GNU not Unix) not Unix!). As you can see this will go on forever and GNU's definition is nested inside itself so it is recursive. The Fibonacci sequence is also recursive: F(n) = F(n-1)+F(n-2). Inside the function F, we see two more F's!</p>

<p>In computer science infinite looping is bad because computers do not know how to terminate so we need some way to stop it. We will call a stopping point the base case. A base case is the case where the recursion will stop. Everything must eventually reduce to a base case. For the Fibonacci sequence, the base case is F(0) = 1 and F(1) = 1 and we can see that for all N&gt;1, the Fibonacci sequence will reach the base case.</p>

<p>So for something to be recursive in computer science, it needs:</p>

<ul>
<li>a recursive definition (contained in itself) and </li>
<li>a base case that all valid inputs will eventually reach</li>
</ul>

<p>Template for recursion:</p>

<pre class="prettyprint linenums ">
recursion(parameter)
    if base_case (parameter):
        stop
    recursion( operation(parameter) )
</pre>

<ul>
<li><em>recursion</em> is the recursive function</li>
<li><em>base_case</em> is the check if the parameter has reached the base case</li>
<li><em>operation</em> reduces the parameters towards the base case</li>
</ul>

</section><h1>Advanced Recursion</h1><section><h2>Introduction</h2>

<p><strong>Prerequisites</strong>: <a href="./Recursion" target="_blank">Recursion</a></p>

<p><strong>Next</strong>: <a href="./Intermediate_Recursion" target="_blank">Intermediate Recursion</a>, <a href="./Backtracking" target="_blank">Backtracking</a>, <a href="./Dynamic_Programming" target="_blank">Dynamic Programming</a></p>

<p>Recursion can sometimes be very difficult to wrap your head around because when you try to go deeper, it only keeps getting deeper. It is sometimes hard to figure out the recurrence relation, but once you do, the problem becomes simple to solve.</p>

</section><section><h2>Number of paths</h2>

<p>Let's say we have a grid of N rows and M columns. How many ways are there to get from the bottom left corner to the top right corner using the intersection points and only going upwards or rightwards?</p>

<p><img src="./public_html/img/uploads/recursion_grid.png"></p>

<p>We see that the only way to reach an intersection is to come from the left intersection or come from the bottom intersection. So the number of ways to reach an intersection is the number of ways to reach the intersection to the left plus the number of ways to reach the intersection on the bottom.</p>

<p>So more accurately, the number of ways to get to intersection N x M is the sum of the ways to get to the intersection N-1 x M and the intersection N x M-1. However, the number of ways to reach the intersection N-1 x M is the sum of the number of ways to the intersection N-2 x M and N-1 x M-1. As we can see, it is a recurrence relation.</p>

<p>The base case is the starting intersection in the bottom left hand corner (the intersection 1x1) which is the only way to reach that intersection. We can also see that there is only one way to reach the intersections on the left side. There is only one way to reach the intersections on the bottom side as well.</p>

<pre class="prettyprint linenums lang-html">
Let path(x,y) be the number of ways to get to the intersection at x and y

Base case:
paths(1,y) = 1
paths(x,1) = 1

Recurrence:
paths(x,y) = paths(x-1,y) + paths(x,y-1)

Example:
paths(3,5)
= paths(2,5) + paths(3,4)
= paths(1,5) + paths(2,4) + paths(2,4) + paths(3,3)
= 1 + paths(1,4) + paths(2,3) + paths(1,4) + paths(2,3) + paths(2,3) + paths(3,2)
= 1 + 1 + paths(1,3) + paths(2,2) + 1 + paths(1,3) + paths(2,2) + paths(1,3) + paths(2,2) + paths(2,2) + paths(3,1)
= 1 + 1 + 1 + paths(1,2) + paths(2,1) + 1 + 1 + path(1,2) + paths(2,1) + 1 + paths(1,2) + paths(2,1) + ....
= 
</pre>

<p><img src="./public_html/img/uploads/recursion_grid2.png"></p>

<pre class="prettyprint linenums ">
int paths(int n,int m){
   if(n==1||m==1){
        return 1;
   }
   return ways(n-1,m) + ways(n,m-1);
}
</pre>

</section><section><h2><a href="./Towers_of_Hanoi" target="_blank">Towers of Hanoi</a></h2>

<p>There are three poles and N disks where each disk is heaver than the next disk. In the initial configuration, the discs are stacked upon another on the first pole where the lighter discs are above the heavier discs. We want to move all the discs to the last pole with the following conditions:</p>

<ul>
<li>Only be moved from one pole to another one at a time.</li>
<li>The discs have to be stacked such that all the lighter discs are on top of the heavier ones.</li>
</ul>

<p>Lets' try to make this problem simpler. To move N discs from the first pole the the last pole we need to move N-1 discs to the middle pole, then move the Nth disc to the last pole, and then move all N-1 discs from the middle pole back on to the last pole.</p>

<p>Let the starting pole be the first pole, the helper pole be the middle pole and the destination pole the third pole.</p>

<p><img src="./public_html/img/uploads/hanoi.png"></p>

<p>To move N discs from the starting pole to the destination pole:</p>

<p><strong>Step 1:</strong></p>

<p>We need to move N-1 discs from the starting pole to the helper pole.
<img src="./public_html/img/uploads/hanoi2.png"></p>

<p><strong>Step 2:</strong></p>

<p>We need to move the Nth disc from the starting pole to the destination pole.
<img src="./public_html/img/uploads/hanoi3.png"></p>

<p><strong>Step 3:</strong></p>

<p>We need to move N-1 discs from the helper pole to the destination pole.
<img src="./public_html/img/uploads/hanoi4.png"></p>

<p>We can see that Step 2 is easy, all we have to do is move that one disc. But for Step 1 and Step 3, we have to move N-1 discs. How can we move N-1 discs to the middle pole?</p>

<p>We see that we can use the same reasoning: we need to move N-2 discs to the third pole. Then we need to move the N-1 disc to the second pole and then move N-2 discs from the third pole to the second pole.</p>

<p>In this case, the start pole is the first pole, the helper pole is the third pole and the destination pole is the middle pole.</p>

<p><img src="./public_html/img/uploads/hanoi.png"></p>

<p>To move N-1 discs from starting pole to destination pole:</p>

<p><strong>Step 1:</strong></p>

<p>We need to move N-2 discs from starting pole to helper pole</p>

<p><img src="./public_html/img/uploads/hanoi5.png"></p>

<p><strong>Step 2:</strong></p>

<p>We move the N-1th disc from the starting pole to the destination pole</p>

<p><img src="./public_html/img/uploads/hanoi6.png"></p>

<p><strong>Step 3:</strong></p>

<p>We move N-2 discs from the helper pole to the destination pole.</p>

<p><img src="./public_html/img/uploads/hanoi2.png"></p>

<p>As we can see, the steps to move N discs are the exact same as to move N-1 discs! The only difference is that the actual poles are different but if we reassign poles to new roles every time we move down a disc, we can build a recurrence relation.</p>

<p>In Step 1, when we move N-1 discs from start to helper, the new helper is the old destination and the new destination is the old helper.</p>

<p>In Step 3, when we move N-1 discs from the helper to the destination, the new helper is the start pole, and the new start pole is the helper</p>

<hr><h3>Formalization</h3>

<pre class="prettyprint linenums lang-html">
Let f(N,start,helper,dest) be the steps to move N discs from the start to dest

Base case:
f(1,start,helper,dest)= Move from (start) to (dest)

Recurrence:
f(N,start,helper,dest)

=

f(N-1,start,dest,helper)
Move from start to dest
f(N-1,helper,start,dest)

Example:
Let A, B, C be pole 1, 2, 3

f(4,A,B,C) 

=

f(3,A,C,B)
Move from A to C
f(3,B,A,C)

=

f(2,A,B,C)
Move from A to B
f(2,C,A,B)
Move from A to C
f(2,B,A,C)
Move from B to C
f(2,A,B,C)

=

f(1,A,C,B)
Move from A to C
f(1,B,A,C)
Move from A to B
f(1,C,B,A)
Move from C to B
f(1,A,C,B)
Move from A to C
f(1,B,C,A)
Move from B to C
f(1,A,B,C)
Move from B to C
f(1,A,C,B)
Move from A to C
f(1,B,A,C)

=

Move from A to B
Move from A to C
Move from B to C
Move from A to B
Move from C to A
Move from C to B
Move from A to B
Move from A to C
Move from B to A
Move from B to C
Move from A to C
Move from B to C
Move from A to B
Move from A to C
Move from B to C

</pre>

</section><section><h2>Permutations</h2>

<p>A permutation is an arrangement of the original set of elements.</p>

<p>For example permutations of A,B,C,D,E,F:</p>

<ul>
<li>D,E,F,C,B,A</li>
<li>F,C,D,B,A,E</li>
<li>B,D,A,E,F,C</li>
<li>A,B,C,D,E,F</li>
</ul>

<p>Given a string S of length N, how can we generate all permutations?</p>

<p>Let's assume that we have a list of permutations for the substring of S of N-1 characters. Then to get the permutations for the string of length N, all we need to do is insert the Nth character in between all the positions of each permutation of N-1 characters. For example permutation of A,B,C,D.</p>

<p>We can manually find the permutations of A,B,C.</p>

<ul>
<li>A,B,C</li>
<li>A,C,B</li>
<li>B,A,C</li>
<li>B,C,A</li>
<li>C,A,B</li>
<li>C,B,A</li>
</ul>

<p>If we insert the letter D between each letter for every permutation we get:</p>

<ul>
<li>D,A,B,C</li>
<li>A,D,B,C</li>
<li>A,B,D,C</li>
<li>A,B,C,D</li>
<li>D,A,C,B</li>
<li>A,D,C,B</li>
<li>A,C,D,B</li>
<li>A,C,B,D
.... etc</li>
</ul>

<p>And we can guarantee that every new permutation will be unique. (Try to prove that to yourself).</p>

<p>But let's look at how we can get the permutation of A,B,C. We can also get all the permutations of the string by taking the permutations of A,B and inserting C in all the positions for all substrings.</p>

<p>Substrings of A,B</p>

<ul>
<li>A, B</li>
<li>B, A</li>
</ul>

<p>Insert C for all positions for all permutations</p>

<ul>
<li>C,A,B</li>
<li>A,C,B</li>
<li>A,B,C</li>
<li>C,B,A</li>
<li>B,C,A</li>
<li>C,B,A</li>
</ul>

<p>We see that we have a recurrence relation. To get the permutations of a string N, we take the string[1..N-1] and we insert the Nth character at every position for each permutation of the N-1 substring. The base case of an empty string is simply an empty string. Permutation of an empty string is an empty list.</p>

<p>For simplicity, S[i..j] will mean the substring from including i to excluding j.</p>

<pre class="prettyprint linenums lang-html">
Let P(S) be the list of permutations for the string S of length N

Base case:
P('') = []

Recurrence:
Let N = length of string S
P(S) = ps[0..i] + S[N] + ps[i..N] for i in 0..N, for ps in P(S[0..N-1])

Example:
P('ABC')
=

</pre>

<hr><h3>Implementation</h3>

<pre class="prettyprint linenums ">
Vector&lt;String&gt; permutation(String s){
   int n = s.length;
   Vector&lt;String&gt; vec = new Vector&lt;String&gt;();
   if(s.length==0)return vec;
   Vector&lt;String&gt; subvec = permutation(s.substring(0,n-1));
   for(int i=0;i&lt;subvec.size();i++){
      String ps = subvec.get(i);
      for(int j=0;j&lt;n;j++){
         vec.push(ps.substring(0,j)+s.charAt(n)+ps.substring(j,n-1));
      }
   }
   return vec;
}
</pre>

</section><section><h2>Exercises</h2>

<ol>
<li>Given a string S, write a recursive function to generate all substrings</li>
<li>Write a solution for hanoi towers but with the restriction that discs can only be moved from adjacent poles. (You can move a disc from A to B but not A to C because they are not adjacent)</li>
</ol>
</section><h0>Sorting</h0><section><h3>Introduction</h3>

<p>Sorting is arranging an array of n elements in either increasing or decreasing order by some property. It is very useful in computer science for efficiency in other algorithms that usually require a search.</p>

<p>A stable sort is a sort that can preserve sorting of other properties. For example if we have</p>

<p>(3,G), (1,G), (3, A), (6 K), (1,B)</p>

<p>and we want to sort by the first property in increasing order, we will have:</p>

<p>(1, G) (1,B) (3,G), (3,A) (6 K).</p>

<p>If we sort again by the second property we have (1,B) (3, A) (1, G) (3, G) (6,K) then the sort is stable as the first sort is preserved. However if we had (1,B) (3, A) (3, G) (1, G) (6, K), then the sort would be unstable.</p>

</section><h1>Bubble Sort</h1><section><h2>Introduction</h2>

<p>Bubble sort is one of the most basic sorting algorithms, one of the first you should learn.</p>

<p>Its name describes how the algorithm works: bigger bubbles float to the top. This will become more clear when we see the implmentation.</p>

<p>The sorting algorithms are implemented to sort integer arrays but can be adapted to sort arrays of any data structure that is comparable.</p>

</section><section><h2>Implementation</h2>

<pre class="prettyprint linenums ">
//sorts integers from smallest to greatest
public static void BubbleSort (int a[]){
    for (int i=0;i&lt;a.length;i++){
        for (int j=1;j&lt;a.length;j++){
            //if the current bubble is smaller than the bubble that's 
            //below then the bigger bubble floats up
            if (a[j]&lt;a[j-1]){
                //swap the bubbles
                int temp = a[j];
                a[j] = a[j-1];
                a[j-1] = temp;
            }
        }
    }
}
</pre>
</section><h1>Selection Sort</h1><section><h2>Introduction</h2>

<p>Selection Sort is similar to Bubble Sort in terms of complexity and arguably more intuitive.</p>

<p>Selection Sort works by selecting the smallest element and setting it as the first item in the array, then selecting the second element and setting that as the second item in the array and so on. This process repeats until the least smallest element (the largest element) is set as the last item in the array.</p>

<p>The sorting algorithms are implemented to sort integer arrays but can be adapted to sort arrays of any data structure that is comparable.</p>

</section><section><h2>Implementation</h2>

<pre class="prettyprint linenums ">
//sorts integers from smallest to greatest
public static void SelectionSort (int a[]){
    //iterates through the array selecting the smallest elements
    for (int i=0;i&lt;a.length-1;i++){
        int minIndex = i;//var for storing where the ith smallest element is
        //iterates through the array looking for the ith smallest element
        for (int j=i+1;j&lt;a.length;j++){
            //if the current element is smaller than the current smallest element
            if (a[j]&lt;a[minIndex]){
                //updated the location of the smallest element
                minIndex = j;
            }
            //swap the current i with the smallest element
            int temp = a[i];
            a[i] = a[minIndex];
            a[minIndex] = temp;
        }
    }
}
</pre>
</section><h1>Insertion Sort</h1><section><h2>Introduction</h2>

<p>Insertion Sort is the another n&lt;sup&gt;2&lt;/sup&gt; sorting algorithm.</p>

<p>It works by starting with an empty sorted sequence of numbers and then inserting every element in the array into the sorted sequence maintaining the order after each insert.</p>

<p>The sorting algorithms are implemented to sort integer arrays but can be adapted to sort arrays of any data structure that is comparable.</p>

</section><section><h2>Implementation</h2>

<pre class="prettyprint linenums ">
//sorts integers from smallest to greatest
public static void InsertionSort (int a[]){
    //iterates through the array selecting the smallest elements
    for (int i=0;i&lt;a.length;i++){
        //element that needs to be inserted into the sorted list
        int val = a[i]; 
        //keeps track of where to insert the element
        int index = i; 
        
        //loops through the already sorted list to find where to 
        //insert the current element
        while (index &gt; 0 &amp;&amp; a[index-1] &gt; val){
            //switches the current item at index with the one before 
            //to check if the element that needs to be inserted will 
            //go in the next spot
            a[index] = a[index-1];
            index--;
        }
        a[index] = val;
    }
}
</pre>
</section><h1>Heap Sort</h1><section><h2>Introduction</h2>

<p><em>Prerequisites</em>: <a href="./Heap" target="_blank">Heap</a></p>

<p>Heap sort is a sort that inserts all the element in an array into a min heap and then pops all the element outs. Since a heap guarantees that the root node will be the smallest element, we can store the entire array in a heap and the order that they are popped out of the heap will be in order.</p>

<hr><h3>Implementation</h3>

<pre class="prettyprint linenums ">
public void heapSort(int[] arr){
    PriorityQueue&lt;Integer&gt; pq; //built in heap
    for(int i=0;i&lt;arr.length;i++){
       pq.push(arr[i]);
    }
    for(int i=0;i&lt;arr.length;i++){
       arr[i] = pq.pop(i);
    }
}
</pre>
</section><h1>Merge Sort</h1><section><h2>Introduction</h2>

<p><strong>Preqrequistes</strong>: <a href="./Recursion" target="_blank">Recursion</a></p>

<p>Merge sort works by breaking down the sorting into smaller pieces. If we want to sort N elements, we can sort the first half of the elements, sort the second half and then merge the results together. To sort the first half, we can do the exact same thing of sorting the first quarter and the second quarter and merging the results.</p>

</section><section><h2>Implementation</h2>

<p>Merge sort work be breaking down the problem into smaller and smaller parts and then combing those parts to solve the big problem.</p>

<p>We can keep splitting the list into half until there each piece has 1 element or no elements. We can then combine the results of each piece repeatedly until the entire list is sorted.</p>

<p>Example:</p>

<p><img src="./public_html/img/uploads/mergesort.png"></p>

<hr><h3>Formalization</h3>

<pre class="prettyprint linenums lang-html">
Let merge(arr1,arr2) combine two sorted arrays into one sorted array

merge(arr1, arr2)= { arr2 if arr1 is empty
                     { arr1 if arr2 is empty
                     { arr1.first + merge(arr1[1..arr1.length],arr2) if arr1.first &lt; arr2.first
                     { arr2.first + merge(arr1[0..arr.length],arr2[1..length]) else

Let sort(arr) sort an array
Let middle be (0+arr.length)/2
sort(arr) = merge(sort(arr[0..middle]) ,sort(arr[middle..arr.length])
</pre>

<hr><h3>Code</h3>

<p>For our Java implementation, instead of returning a new array every time we merge two arrays, we can create a temporary array to store the merged results and then move it back.</p>

<pre class="prettyprint linenums ">
/**
 * Merges two segments of the same array. The two segments should be adjacent.
 * @param arr Array containing segments
 * @param start1 Start index of first segment
 * @param end1 End index of first segment
 * @param start2 Start index of second segment
 * @param end2 End index of second segment
 */

public static void merge(int arr[],int start1,int end1, int start2,int end2){
    int arr2[] = new int[end2-start1+1];
    int begin = start1;
    int n = 0;
    
    //Pick smallest element one by one
    while(start1 &lt;= end1 &amp;&amp; start2 &lt;= end2){
        if(arr[start1] &lt;= arr[start2]){
            arr2[n] = arr[start1];
            start1++;
        }else{
            arr2[n] = arr[start2];
            start2++;
        }
        n++;
    }
    //If first segment still has elements
    while(start1 &lt;= end1){
        arr2[n] = arr[start1];
        n++;
        start1++;
    }
    //if second segment still has elements
    while(start2 &lt;= end2){
        arr2[n] = arr[start2];
        start2++;
        n++;
    }
    //Copy merged array back
    for(int i=0;i&lt;n;i++){
        arr[begin+i]=arr2[i];
    }
}
/**
 * Sorts an array using merge sort
 * @param arr Array to be sorted
 * @param start Index at beginning of array
 * @param end Index at end of array
 */
public static void mergeSort(int arr[],int start,int end){
    if(end-start&lt;=0){
        return;
    }
    int mid = (start+end)/2;
    mergeSort(arr,start,mid);
    mergeSort(arr,mid+1,end);
    merge(arr,start,mid,mid+1,end);
}

public static void main(){
    int arr[] = {5,7,2,6,8,5};
    mergeSort(arr,0,arr.length-1);
}
</pre>
</section><h1>Quick Sort</h1><section><h2>Introduction</h2>

<p>Quick Sort is another fast sorting algorithm that uses divide and conquer. It is also known as partition-exchange sort or as Hoare's quicksort (named after the author).</p>

<p>In Quick Sort an element is selected as a "pivot". The list is then divided into two sublists: a list of elements less than (or equal to) the pivot and a list of elements greater than the pivot. Each sublist is sorted (conquered) and then appended together along with the origin pivot.</p>

<p>In the best case (if the pivot that is chosen is exactly the middle element), then the runtime is O(n log n). However, in the worst case, the runtime for Quick Sort is n<sup>2</sup>. Despite its worst case behaviour, quick sort is still popular and in widespread use. The average case behaviour is quite good and there are straightforward methods that can be used to improve the selection of the pivot.</p>

<p>The sorting algorithms are implemented to sort integer arrays but can be adapted to sort arrays of any data structure that is comparable.</p>

</section><section><h2>Implementation</h2>

<p><img src="./public_html/img/uploads/quicksort.png"></p>

<pre class="prettyprint linenums ">
//sorts integers from smallest to greatest
public static void QuickSort (int a[], int first, int last){
    //first is the starting index of the list
    //last is the last index of the list
    //QuickSort can be called by QuickSort(a, 0, a.length-1)
    
    if (last &lt;= first) return; //if the array size &lt;= 1
    
    int pivot = a[first]; //picks the first element as the pivot
    // the location to put the next integer that's larger than the pivot
    int index = last;  
    
    //iterate through the list, sorting it by the first pivot
    for (int i=last;i&gt;=first+1;i--){
        if (a[i]&gt;=pivot){
            //swap the current element to be on the side that's 
            //larger than the pivot
            int temp = a[index];
            a[index] = a[i];
            a[i] = temp;
            
            //decrements index for the next switch
            index--;
        }
    }
    
    //swap the element at index with the pivot so that it's 
    //in the right place
    int temp = pivot;
    a[first] = a[index];
    a[index] = pivot;
    
    //recursively sort the lists less than and greater than the pivot
    QuickSort (a, first, index-1);
    QuickSort (a, index+1, last);
}
</pre>
</section><h1>Bozo Sort</h1><section><h2>Introduction</h2>

<p>Bozo sort is a sort that keeps randomly arranging an array until it is sorted. If you are very lucky bozo sort will be very fast! But for the most part this is a horrible sort.</p>

</section><section><h2>Implementation</h2>

<pre class="prettyprint linenums ">
public void bozoSort(int[] arr){
   
   boolean sorted = false;
   int i = 0;

   while(!sorted){
       sorted = true;
       for(i=1;i&lt;arr.length;i++){
          if(arr[i]&lt;arr[i-1]){
             sorted = false;
             break;
          }
       }
       if(sorted)return;

       for(i=0;i&lt;arr.length;i++){
           int x = Math.randInt(arr.length);
           int y = Math.randInt(arr.length);
           int temp = arr[x];
           arr[x] = arr[y];
           arr[y] = temp;
       }

   }
}

</pre>
</section><h1>Permutation Sort</h1><section><h2>Introduction</h2>

<p>Permutation sort is a sort that keeps permutating the array until it is sorted. It is the slowest sort that will guarantee that the array will be sorted.</p>

<hr><h3>Implementation</h3>

<pre class="prettyprint linenums ">
void permuteSort(int[] arr){
  while(!sorted(arr)){
    permute(arr);
  }
}
</pre>
</section><h1>Miracle Sort</h1><section><h2>Introduction</h2>

<p><em>Prerequisites</em>: Miracles, Sense of Humour</p>

<p>Miracle sort is a sort that truly requires a miracle. We keep checking the array until it is sorted. It requires that some external force (a miracle?) changes some bits in the computer in a way that it becomes sorted.</p>

</section><section><h2>Implementation</h2>

<pre class="prettyprint linenums ">
public void miracleSort(int[] arr){
   boolean sorted = false;
   do{
      sorted = true;
      for(int i=1;i&lt;arr.length;i++){
         if(arr[i]&lt;arr[i-1]){
             sorted = false;
             break;
         }
      }
   }while(!sorted);
}
</pre>
</section><h0>Data Structures</h0><section><h3>Introduction</h3>

<p>Data structures are a way of storing data such that it can be used in an efficient way. Although many of these data structures are already built into various languages, it is important to understand how they work. By understanding the implementations we can have a sense of which data structure to use in different problems as well as determine how efficient they are.</p>

<p>An <strong>abstract data type</strong> is a conceptual model for representing data. An abstract data type tells what it should do as opposed to how it should work. It will tell us what operations it should have but should not tell us how to implement them.</p>

<p>For example, a bottle should be able to hold water and allow us to drink from. This tells us what it should do but we don't need to know how it works or how it is made. A plastic water bottle is an implementation of a bottle. It holds water in its interior and allows us to drink by unscrewing the cap and letting us pour water down our throat. A thermos is also an implementation of the bottle, it holds fluid inside it, but this thermos has a lid that can be popped open and water can come from it. A thermos and plastic water bottle are different implementations as they are made differently and used differently, but they fundamentally do what a bottle is supposed to do: store liquid, and provide a way to drink. A bottle does not actually exist, but types of bottles do.</p>

<p><img src="./public_html/img/uploads/bottle.png"></p>

<p>Some implementations of abstract data types are better than others for different purposes. For example plastic water bottles are very cheap whereas a thermos is more expensive but a thermos can hold hot water and keep it warm for a long period of time. When thinking of a implementation for an abstract data type we need to know what we need it for.</p>

<p><img src="./public_html/img/uploads/adt.png"></p>

<p>For more intermediate data structures, read the <a href="./Advanced_Data_Structures" target="_blank">advanced data structures</a> page.</p>

</section><h1>Arrays</h1><section><h2>Introduction</h2>

<p><a href="https://github.com/ayoungprogrammer/Algorithms/blob/master/src/Arr.java" target="_blank">Source on Github</a></p>

<p>Imagine you had a row of parking spaces where each was labelled with a number. If you wanted to know what the license plate of a car at parking space 4 was, all you have to do is go to the parking space and read off the license plate. If you wanted to park you car at parking space 5, you would go to parking space 5 and put your car in there if there was nothing there. Let's say that you had cars at parking spaces 1, 2, and 3. If you wanted to insert a new car at parking space 1 and keep the rest of the cars in the same order, you would have to shift the cars in the parking spaces from 1, 2 and 3 to 2, 3 and 4 by getting in each car and parking them in the new spaces which would take some time. This type of structure is an array.</p>

<p>An <strong>array</strong> is the most basic data structure that stores elements of the same type in a fixed block. The fact that it is in one block and the same type is important because it allows accessing elements very quickly if you have the index. All you have to do is go to the index and retrieve the element. However, inserting elements in the array is slow because you would have to shift all the elements and also if you want to shift past the fixed size you will get an error. (Imagine the parking spaces are full and you wanted to insert a car somewhere, there will still be one car that will have no parking space).</p>

<p>Arrays can be multidimensional meaning you can have an array of array of objects. (Imagine a parking lot with multiple rows of parking spaces).</p>

<table>
<thead>
<tr>
  <th>Operation</th>
  <th>Create</th>
  <th>Get i</th>
  <th>Set i</th>
</tr>
</thead>
<tbody>
<tr>
  <td>Time Complexity</td>
  <td>O(n)</td>
  <td>O(1)</td>
  <td>O(1)</td>
</tr>
</tbody>
</table>

</section><section><h2>Implementation</h2>

<p>Implementation of a very simple array in Java</p>

<hr><h3>Create array</h3>

<p>Creating an array allocates a block of memory for us to store the elements.</p>

<pre class="prettyprint linenums ">
public static int[] createArray(int size){
     int[] array = new int[size];
     return array;
}
</pre>

<hr><h3>Get</h3>

<p>When we want to get the element of an index all we have to do is offset the index by the array. However we need to check that the index is within bounds of the array.</p>

<pre class="prettyprint linenums ">
public static int getElemenent(int[] arr, int i){
    if(i&lt;0 || i&gt;=arr.length){
        throw new ArrayIndexOutOfBoundsException();
    }
    return arr[i];
}
</pre>

<hr><h3>Set</h3>

<p>Setting is very similar to getting but instead we change the value in the array.</p>

<pre class="prettyprint linenums ">
public static void setElemenent(int[] arr, int i,int value){
    if(i&lt;0 || i&gt;=arr.length){
        throw new ArrayIndexOutOfBoundsException();
    }
    arr[i] = value;
}
</pre>

</section><section><h2>See Also</h2>

<ul>
<li><a href="./Vector" target="_blank">Vector</a></li>
<li><a href="./Stack" target="_blank">Stack</a></li>
</ul>
</section><h1>Stack</h1><section><h2>Introduction</h2>

<p>Imagine a stack of plates at a buffet, the plates are taken from the top and are also replaced from the top. The first plate to go in will be the last plate to come out. The last plate to go in will be the first to come out. This structure is called a stack.</p>

<p>A <strong>stack</strong> is an abstract data type with the property that it can remove and insert elements following a FILO (First In Last Out) structure. The first element to be inserted must be the last element to be removed and the last element to be inserted must be the first element to be removed. Sometimes, removal is called "pop" and insertion is called "push".</p>

<p>Example of push:</p>

<p><img src="./public_html/img/uploads/stack.png"></p>

<p>Example of pop:</p>

<p><img src="./public_html/img/uploads/stack2.png"></p>

<p>Stacks are used for function calls on the memory stack. Whenever a function is called, it is placed on the memory stack with its variables and when it is returning a value, it is popped off the stack.</p>

<p>A stack is usually implemented as a <a href="./Vector" target="_blank">vector</a>.</p>

</section><section><h2>Implementation</h2>

<table>
<thead>
<tr>
  <th>Implementation</th>
  <th>Pop</th>
  <th>Push</th>
</tr>
</thead>
<tbody>
<tr>
  <td><a href="./Vector" target="_blank">Vector</a></td>
  <td>O(1)</td>
  <td>O(1)</td>
</tr>
</tbody>
</table>

</section><section><h2>Exercises</h2>

<ol>
<li><p>Given a string of brackets of either () or [], determine if the bracket syntax is legal (every opening bracket has a closing bracket from left to right).</p>

<p>Legal syntax:</p>

<ul>
<li>( [ ( ) [ ] ] )</li>
<li>( ) ( ) [ ] ( ) ( )</li>
</ul>

<p>Illegal syntax:</p>

<ul>
<li>( ( ) ]</li>
<li>( ) [ ( ] )</li>
</ul></li>
</ol>
</section><h1>Vector</h1><section><h2>Introduction</h2>

<p><em>Prerequisites</em>: <a href="./Arrays" target="_blank">Arrays</a>, <a href="./Stack" target="_blank">Stack</a></p>

<p><a href="https://github.com/ayoungprogrammer/Algorithms/blob/master/src/Vec.java" target="_blank">Source on Github</a></p>

<p>A vector is a stack that is implemented as an <a href="./Array" target="_blank">array</a>. It is very similar to an <a href="./Array" target="_blank">array</a>, but it is more flexible in terms of size. Elements are added and removed only from the end of the array. When more elements are added to the vector and the vector is at full capacity, the vector resizes itself and reallocates for 2*N space. When using an vector we can keep adding elements and let the data structure handle all the memory allocation.</p>

<table>
<thead>
<tr>
  <th>Operation</th>
  <th>Get</th>
  <th>Push</th>
  <th>Pop</th>
  <th>Insert</th>
  <th>Delete</th>
</tr>
</thead>
<tbody>
<tr>
  <td>Time Complexity</td>
  <td>O(1)</td>
  <td>O(1)</td>
  <td>O(1)</td>
  <td>O(n)</td>
  <td>O(n)</td>
</tr>
</tbody>
</table>

</section><section><h2>Implementation</h2>

<p>There is a builtin Vector class already, but we will go through the implementation of a simple integer vector class to understand how the data structure works.</p>

<hr><h3>Class</h3>

<p>In our vector class, we need to store the element and the size of the current vector.</p>

<pre class="prettyprint linenums ">
class Vec{
    private int[] arr; //Storage of elements
    private int size; //Current size
}

//Constructor
publc Vec(int startSize){
    arr = new int[startSize];
    this.size = 0;
}

</pre>

<hr><h3>Resize</h3>

<p>Resize will be used to resize the current size of elements. We create a new array of two times the size of the old one and copy the old array over.</p>

<p><img src="./public_html/img/uploads/vector3.png"></p>

<pre class="prettyprint linenums ">
public void resize(){
    int[] newArr = new int[2*arr.length];
    for(int i=0;i&lt;end;i++){
        newArr[i] = arr[i];
    }
    arr = newArr;
}
</pre>

</section><section><h2>Add Element</h2>

<p>Add element will add elements to the end of the vector. If the array is full, the vector will resize itself.</p>

<p><img src="./public_html/img/uploads/vector2.png"></p>

<pre class="prettyprint linenums ">
public void add(int x){
        if(size&gt;=arr.length){
        resize();
    }
    arr[size] = x;
    end++;
}
</pre>

</section><section><h2>Pop</h2>

<p>Removes the element at the end of the vector. We decrease the size of the vector and return the last element.</p>

<p><img src="./public_html/img/uploads/vector4.png"></p>

<pre class="prettyprint linenums ">
public int pop(){
    if(size==0){
        throw new NoSuchElementException();
    }
    int ret = arr[size];
    size--;
    return ret;
}
</pre>

</section><section><h2>Remove</h2>

<p>Removes element at the index idx. It will throw an exception if the index is out of bounds.</p>

<p>We shift everything to the right of the index to the left by one to fill in the missing element.</p>

<p><img src="./public_html/img/uploads/vector4.png"></p>

<pre class="prettyprint linenums ">
public int remove(int idx){
    if(idx&lt;0||idx&gt;=size){
        throw new ArrayIndexOutOfBoundsException();
    }
    int ret = arr[idx];
    while(idx+1&lt;size){
        arr[idx]=arr[idx+1];
        idx++;
    }
    size--;
    return ret;
}
</pre>

</section><section><h2>Get Element</h2>

<p>Returns the element at the specified index. It will throw an exception if the index is out of bounds. Note this function is exactly as the same as in the <a href="./Array" target="_blank">array</a></p>

<p><img src="./public_html/img/uploads/vectorget.png"></p>

<pre class="prettyprint linenums ">
public int get(int idx){
    if(idx&lt;0||idx&gt;=size){
        throw new ArrayIndexOutOfBoundsException();
    }   
    return arr[idx];
}
</pre>

</section><section><h2>Insert Element</h2>

<p>Insert the new number x at the index. We need to make space at the index for the new element so we shift everything to the right of the index by 1.</p>

<p><img src="./public_html/img/uploads/vectorinsert.png"></p>

<p><img src="./public_html/img/uploads/vectorinsert2.png"></p>

<pre class="prettyprint linenums ">
public void insert(int idx,int x){
    if(idx&lt;0||idx&gt;size){
        throw new ArrayIndexOutOfBoundsException();
    }
    size++;
    if(size&gt;=arr.length){
        resize();
    }
    //Shift elements to the right or idx by 1
    int idx2 = size;
    while(idx2&gt;idx){
        arr[idx2]=arr[idx2-1];
        idx2--;
    }   
    arr[idx] = x;
    }
</pre>

</section><section><h2><a href="./Exercises" target="_blank">Exercises</a></h2>

<ol>
<li>Implement removeAtIndex(int index) for Vector</li>
</ol>
</section><h1>Queue</h1><section><h2>Introduction</h2>

<p>Imagine you are standing in line for a restaurant. Whoever is first in line will be served first and whoever is last in line will be served last. People can be served while more people join the line and the line may get very long because it takes a while to serve one person while more people join the queue. This is called a queue.</p>

<p>A <strong>queue</strong> is an abstract data type with two functions, pop and push. Removal from the front is called "pop" or "dequeue". Insertion from the back is called "push" or "enqueue". A queue follows a First In First Out (FIFO) structure meaning the first element pushed should be the first element popped and the last element pushed should be the last element popped.</p>

<p>Queues are often used for buffer systems, for example a text message service. The messages that arrive at the server first are relayed first and the messages that arrive later are relayed later. If there are too many text messages in the system such that the rate  texts are received overwhelm the number of texts that are sent the buffer may overflow and messages will get dropped. Most of the time this won't happen because the systems are designed to handle large loads, but if there were an emergency that caused everyone to start texting many texts could be dropped.</p>

<p>Example of push:</p>

<p><img src="./public_html/img/uploads/queue.png"></p>

<p>Example of pop:</p>

<p><img src="./public_html/img/uploads/queue2.png"></p>

</section><section><h2>Implementation</h2>

<p>We can implement a queue most efficiently using a linked list because it has an efficient memory allocation.</p>

<table>
<thead>
<tr>
  <th>Implementation</th>
  <th>Pop</th>
  <th>Push</th>
</tr>
</thead>
<tbody>
<tr>
  <td><a href="./Linked_List" target="_blank">Linked List</a></td>
  <td>O(1)</td>
  <td>O(1)</td>
</tr>
</tbody>
</table>

</section><section><h2>Exercises</h2>

<ol>
<li><p>Given a list of letters representing instructions where the first instruction is executed, output what the final list should look like after N instructions are executed.</p>

<p>First instruction:</p>

<ul>
<li>A. Add B to the end of the list of instructions</li>
<li>B. Do nothing</li>
<li>C. Add two A's to the front of the list of instructions</li>
</ul>

<p>Example:</p>

<ul>
<li>ABC</li>
<li>BCB</li>
<li>CB</li>
<li>AAB</li>
<li>ABB</li>
<li>BBB</li>
<li>BB</li>
<li>B</li>
</ul></li>
</ol>
</section><h1>Linked List</h1><section><h2>Introduction</h2>

<p><em>Prerequisites</em>: <a href="./Queue" target="_blank">Queue</a></p>

<p><a href="https://github.com/ayoungprogrammer/Algorithms/blob/master/src/LinkedList.java" target="_blank">Source on Github</a></p>

<p>Imagine you had some train cars that were linked together where each was labelled on the inside with a different letter. If you had to find a specific letter you would have to start at the first train car and look inside to check the letter and then walk into the next train car to check the letter and so forth until you found the train car you wanted. If you wanted to insert a train car somewhere all you would have to do it unlink the position where you wanted to insert it and then relink the new train car with the other cars. If you wanted to remove a train car all you would have to do is unlink that car from the other cars and then create a new link to the cars that were adjacent to it. This sort of structure is called a linked list.</p>

<p>A <strong>pointer</strong> is something that holds the memory location of another object.</p>

<p><img src="./public_html/img/uploads/linkedlist.png"></p>

<p>A <strong>linked list</strong> is similar to an array but it is different such that it is not stored in one block of data. Each element can be stored in a random place in memory but each element contains a pointer to the next element thus forming a chain of pointers. Think of a pointer as a link that links two train cars. Since the elements aren't in a block, accessing an element must be done by traversing the entire linked list by following each pointer to the next. However, this also allows insertion to be done more quickly by simply changing the point of the previous element and setting to the pointer of the current element to the next element. Deletion is also done by taking the previous element and changing its pointer to two elements ahead. In a linked list the links only go forward and you cannot move backward.</p>

<p>A <strong>doubly linked list</strong> is a linked list that has pointers going backwards as well as forwards.</p>

<p><img src="./public_html/img/uploads/doublelinkedlist.png"></p>

<table>
<thead>
<tr>
  <th>Operation</th>
  <th>Get</th>
  <th>Push</th>
  <th>Delete</th>
  <th>Insert</th>
</tr>
</thead>
<tbody>
<tr>
  <td>Time Complexity</td>
  <td>O(n)</td>
  <td>O(1)</td>
  <td>O(1)</td>
  <td>O(1)</td>
</tr>
</tbody>
</table>

</section><section><h2>Implementation</h2>

<p>In Java, there already exists a LinkedList class but we will implement our own.</p>

<hr><h3>Link Class</h3>

<p>The Link class for each "link" in the Linked List. In each Link we only need the value and location of the previous and next node.</p>

<pre class="prettyprint linenums ">
class Link{
    int value;
    Link next;
    public Link(int value){
        this.value = value;
        this.next = null;
    }
}
</pre>

<hr><h3>Class</h3>

<p>Create the linked list by initializing the starting node as null and setting the size to empty.</p>

<pre class="prettyprint linenums ">
class LinkedList{
    Link head;
    Link end;
    int size;
    public LinkedList(){
        start = end = null;
        size = 0;
    }
}
</pre>

<hr><h3>Push</h3>

<p>Create a new node with the value given and add it to the end. We have to set the current head previous node to the new node and the new next next to the last node.</p>

<p><img src="./public_html/img/uploads/linkedlistpush.png"></p>

<p><img src="./public_html/img/uploads/linkedlistpush2.png"></p>

<p><img src="./public_html/img/uploads/linkedlistpush3.png"></p>

<pre class="prettyprint linenums ">
/*
 * Adds new node to head of linked list
 */
public void push(int value){
    Link newLink = new Link(value);
    if(size==0){
        head = end = newLink;
    }else{
        end.next = newLink;
        end = newLink;
    }
    size++;
}
</pre>

<hr><h3>Pop</h3>

<p>Pops off the node at the head.</p>

<p><img src="./public_html/img/uploads/linkedlistpop.png"></p>

<p><img src="./public_html/img/uploads/linkedlistpop2.png"></p>

<pre class="prettyprint linenums ">
/*
 * Adds new node to head of linked list
 */
public int pop(){
    if(head==null){
        throw new NoSuchElementException();
    }
    int ret = head.value;
    head = head.next;
    size--;
    if(size==0){
        end = null;
    }
    return ret;
}
</pre>

<hr><h3>Get</h3>

<p>Get retrieves the value at the specified index. We have to loop through the entire list to get the index we want because the nodes are not in the same block of memory.</p>

<p><img src="./public_html/img/uploads/linkedlistget.png"></p>

<p><img src="./public_html/img/uploads/linkedlistget2.png"></p>

<p><img src="./public_html/img/uploads/linkedlistget3.png"></p>

<pre class="prettyprint linenums ">
/*
* Gets the value at index
*/
public int get(int index){
    int i = 0;
    Link curNode = head;
    while(curNode!=null){
        if(index==i){
            return curNode.value;
        }
        curNode = curNode.next;
        i++;
    }
    throw new NoSuchElementException();
}
</pre>

<hr><h3>Delete</h3>

<p>To delete the current node we set the previous node next link to the link after.</p>

<p><img src="./public_html/img/uploads/linkedlistrem.png"></p>

<p><img src="./public_html/img/uploads/linkedlistrem2.png"></p>

<pre class="prettyprint linenums ">
/*
 * Deletes node after specified
 */
public void deleteNext(Link node){
    if(node.next==end){
        end = node;
    }
    node.next = node.next.next;
    size--;
}
</pre>

</section><section><h2>Exercises</h2>

<ol>
<li>Implement a doubly linked list.</li>
<li><p>A game is player by always eliminating the kth player from the last elimination and played until one player is left. Given N players each assigned to a number, find the number of the last player.</p>

<p>For example, you have 5 players (1,2,3,4,5) and the 3rd player is eliminated.</p>

<ul>
<li>1, 2, 3, 4, 5 </li>
<li>1, 2, 4, 5 (1, 2, 3 is eliminated)</li>
<li>2, 4, 5 (4, 5, 1 is eliminated)</li>
<li>2, 4 (2, 4, 5 is eliminated)</li>
<li>2 (2, 4, 2 is eliminated)</li>
<li>Player 2 is the last one standing.</li>
</ul></li>
<li>Given two linked lists which may share tails, determine the point at which they converge.</li>
</ol>
</section><h1>Trees</h1><section><h2>Introduction</h2>

<p>Trees are data structures that follow a hierarchy, each node has exactly one or zero parents and each node has children. Trees are recursive structures meaning that each child of a tree is also a tree. A tree within another tree is called a <strong>subtree</strong>.</p>

<p>A <strong>child</strong> is a node that is below another node.</p>

<p>A <strong>parent</strong> is a node that is above another node.</p>

<p>The element at the top of the tree with no parents is called a <strong>root</strong>. The node at the bottom of the tree with no children is called a <strong>leaf</strong>.</p>

<p>Each node can hold different kinds of information depending on the tree. A node can hold the children it has, the parent it has, a key associated with the node and a value associated with the node.</p>

<p><img src="./public_html/img/uploads/tree.png"></p>

<ul>
<li>A is the root of the tree and E,F,G,H are leaves. </li>
<li>The parent of E is B. </li>
<li>C,F,G is a subtree of the original tree.</li>
</ul>

</section><section><h2><a href="./Binary_Tree" target="_blank">Binary Tree</a></h2>

<p>A binary tree is a tree where every node has at max two children.</p>

<p><img src="./public_html/img/uploads/binarytree.png"></p>
</section><h1>Binary Tree</h1><section><h2>Introduction</h2>

<p>A binary tree is a tree such that each node has at most 2 children.</p>

<p><img src="./public_html/img/uploads/binarytree.png"></p>

</section><section><h2><a href="./Binary_Search_Tree" target="_blank">Binary Search Tree</a></h2>

<p>A binary search tree is a type of binary tree where all the nodes in a left subtree will be smaller than the node and all the nodes in a right subtree will be greater than the node. It has a recursive structure such that each subtree is also a binary search tree.</p>

<p><img src="./public_html/img/uploads/bst.png"></p>
</section><h1>Sets</h1><section><h2>Introduction</h2>

<p>Imagine you have a grocery list that you use to keep tracking of things you need to buy. You want to make sure there are no duplicate items in the list, you can add items to the list and that you can remove items from your list. This structure is similar to what a set does.</p>

<p>Sets are abstract data structures which are able to store values and are used for three operations: insertion, deletion and membership test.</p>

<p>Insertion places an element into the set, deletion removes an element from the set and a <strong>membership</strong> test is checking whether an element exists within the set.</p>

</section><section><h2>Implementation</h2>

<table>
<thead>
<tr>
  <th>Type</th>
  <th>Membership</th>
  <th>Insertion</th>
  <th>Deletion</th>
</tr>
</thead>
<tbody>
<tr>
  <td><a href="./Tree_Set" target="_blank">Tree Set</a></td>
  <td>O(log n)</td>
  <td>O(log n)</td>
  <td>O(log n)</td>
</tr>
<tr>
  <td><a href="./Hash_Set" target="_blank">Hash Set</a></td>
  <td>O(1)</td>
  <td>O(1)</td>
  <td>O(1)</td>
</tr>
</tbody>
</table>

</section><section><h2>Exercises</h2>

<ol>
<li>Given a list of words, determine how many of them are anagrams of each other. An anagram is a word that can have its letters scrambled into another word. 

<ul>
<li>For example silent and listen are anagrams but banana and orange are not.</li>
</ul></li>
<li>Given two lists of friends, find the number of mutual friends.</li>
<li>Given a list of numbers, find the number of tuples of size 4 that add to 0. 

<ul>
<li>For example in the list (10,5,-1, 3, 4, -6) the tuple of size 4 (-1,3,4-6) adds to 0.</li>
</ul></li>
</ol>
</section><h1>Hash Set</h1><section><h2>Introduction</h2>

<p><em>Prerequisites</em>: <a href="./Sets" target="_blank">Sets</a></p>

<p><a href="https://github.com/ayoungprogrammer/Algorithms/blob/master/src/HashSet.java" target="_blank">Source on Github</a></p>

<p>Hash sets are sets that use hashes to store elements. A hashing algorithm is an algorithm that takes an element and converts it to a smaller chunk called a <strong>hash</strong>. For example let our hashing algorithm be (x mod 10). So the hashes of 232, 217 and 19 are 2,7, and 9 respectively.</p>

<p><img src="./public_html/img/uploads/hashcode.png"></p>

<p>For every element in a hash set, the hash is computed and elements with the same hash are grouped together and stored in a <a href="./Linked_List" target="_blank">linked list</a>. The linked list is called a <strong>bucket</strong>.</p>

<p>If we want to check if an element already exists within the set, we first compute the hash of the element and then search through the linked list associated with the hash to see if the element is contained.</p>

<p><img src="./public_html/img/uploads/hashset.png"></p>

<table>
<thead>
<tr>
  <th>Operation</th>
  <th>Membership</th>
  <th>Insertion</th>
  <th>Deletion</th>
</tr>
</thead>
<tbody>
<tr>
  <td>Time Complexity</td>
  <td>O(1)</td>
  <td>O(1)</td>
  <td>O(1)</td>
</tr>
</tbody>
</table>

<hr><h3>Prerequisites</h3>

<ul>
<li><a href="./Sets" target="_blank">Sets</a></li>
<li><a href="./Linked_List" target="_blank">Linked List</a></li>
</ul>

</section><section><h2>Implementation</h2>

<p>Let use the example of the hashset of the elements of 3242, 3523, 123, 235 and 538. The hash set looks like this when computed:</p>

<p><img src="./public_html/img/uploads/hashset.png"></p>

<p>If we wanted to check if 7238 was in the hash set, we would get the hash (7238 mod 10 = 8). So we get the bucket associated with the hash 8 and we get the list of (538). When we iterate through this short list, we see that 7238 is not a member of the set.</p>

<p>Similarly, if we wanted to insert 7238 into the hash set, we would check if it exists and if it did not we would append the element to the end of the bucket. For deletion we would find 7238 check if it existed in the set and remove it from the bucket.</p>

<p>Hash sets are very efficient in all three set operations if a good hashing algorithm is used. When the objects are that being stored are large then hash sets are effective as a set.</p>

<hr><h3>Class</h3>

<p>Inside our implementation of a hash set we will store the buckets using an array of linked lists, the number of buckets, and the number of elements in the set.</p>

<p>The collision chance is the threshold for resizing the hash set. When the ratio of elements in the set to number of buckets is greater than the threshold, then the chance of collision will be high enough that it will slow down the operations. The lower this ratio, the better performing a hash set will be.</p>

<pre class="prettyprint linenums ">
public class HashSet {

    public LinkedList&lt;Integer&gt;[] buckets;
    public int bucketsSize = 10;
    public int size = 0;
    public static final double COLLISION_CHANCE = 0.3;
    
    public HashSet(){
        buckets = new LinkedList[10];
        for(int i=0;i&lt;bucketsSize;i++){
            buckets[i] = new LinkedList&lt;Integer&gt;();
        }
        size = 0;
    }
</pre>

<hr><h3>Hash code</h3>

<p>The hash code is the result of the hashing algorithm for an element. In our hash set implementation, we will use a simple hash: modulus of the integer by the number of buckets.</p>

<p><img src="./public_html/img/uploads/hashcode.png"></p>

<p>For the most part if the numbers are all random then the hash function is fine. However, if the number of buckets was 10 and we added the elements 20,30,40,50,60,70, they will all end up in the same bucket and results in poor performance.</p>

<pre class="prettyprint linenums ">
public int getHash(int x,int hashSize){
    return x % hashSize;
}
</pre>

<hr><h3>Resize</h3>

<p>A hash set must be able to resize. When the ratio of number of elements to number of buckets, the chance of collision will increase more and more. So we must able to resize the number of buckets to support the number of elements to lower the chance of collision.</p>

<p>To resize efficiently, we can create two times the number of buckets and set them to empty and then insert all the elements in the old buckets to the new buckets.</p>

<pre class="prettyprint linenums ">
public void resize(){
    int newBucketsSize = bucketsSize*2;
    LinkedList&lt;Integer&gt;[] newBuckets = new LinkedList[newBucketsSize];
    for(int i=0;i&lt;newBucketsSize;i++){
        newBuckets[i] = new LinkedList&lt;Integer&gt;();
    }
    for(int i=0;i&lt;bucketsSize;i++){
        for(Integer y:buckets[i]){
            int hash = getHash(y,newBucketsSize);
            newBuckets[hash].push(y);
        }
    }
    buckets = newBuckets;
    bucketsSize = newBucketsSize;
}
</pre>

<hr><h3>Insert</h3>

<p>To insert an element in a hash set, we get the hash code from our hashing algorithm and insert the element into the corresponding bucket.</p>

<p><img src="./public_html/img/uploads/hashset.png"></p>

<p><img src="./public_html/img/uploads/hashsetinsert.png"></p>

<p>The function will return method or not the operation was successful. If the bucket already contains the element the operation will stop because we do not want to add duplicate elements into the set. If the bucket does not contain the element, we will insert it into the bucket and the operation is successful.</p>

<pre class="prettyprint linenums ">
public boolean insert(int x){
    int hash = getHash(x,bucketsSize);
        
    LinkedList&lt;Integer&gt; curBucket = buckets[hash];
    if(curBucket.contains(x)){
        return false;
    }
    curBucket.push(x);
    if( (float)size/bucketsSize&gt;COLLISION_CHANCE){
        resize();
    }
    size++;
    return true;
}
</pre>

<hr><h3>Contains</h3>

<p>To check if a hash set contains an element, we get the hash code from our hashing algorithm and check if the corresponding bucket contains the element.</p>

<p><img src="./public_html/img/uploads/hashsetcontains.png"></p>

<p><img src="./public_html/img/uploads/hashsetcontains2.png"></p>

<p><img src="./public_html/img/uploads/hashsetcontains3.png"></p>

<pre class="prettyprint linenums ">
public boolean contains(int x){
    int hash = getHash(x,bucketsSize);
    LinkedList&lt;Integer&gt; curBucket = buckets[hash];
    return curBucket.contains(x);
}
</pre>

<hr><h3>Remove</h3>

<p>To remove an element from a hash set, we get the hash code from our hashing algorithm and remove the element from the corresponding bucket.</p>

<p>The function will return whether or not the operation was successful. If the bucket contains the element we can remove it from the linked list and the operation is successful. If the element is not in the bucket then the operation fails because we cannot remove something that is not there.</p>

<p><img src="./public_html/img/uploads/hashsetrem.png"></p>

<p><img src="./public_html/img/uploads/hashsetrem2.png"></p>

<p><img src="./public_html/img/uploads/hashsetrem3.png"></p>

<pre class="prettyprint linenums ">
public boolean remove(int x){
    int hash = getHash(x,bucketsSize);
    
    LinkedList&lt;Integer&gt; curBucket = buckets[hash];
    if(curBucket.remove((Integer)x)){
        return true;
    }
    return false;
}
</pre>

</section><section><h2>Exercises</h2>

<ol>
<li>Try to come up with a better hashing algorithm</li>
<li>Calculate the probability of a collision occurring given the number of buckets and number of elements in the hash set</li>
<li>Given an array of numbers, find the number of pairs of numbers that sum to 0.</li>
<li>Given an array of numbers and a number A, find the number of pairs of numbers that sum to A.</li>
<li>Given an array of numbers and a number A, find the number of quadruples that sum to A.</li>
</ol>
</section><h1>Tree Set</h1><section><h2>Introduction</h2>

<p><em>Prerequeisites</em>: <a href="./Sets" target="_blank">Sets</a>, <a href="./Binary_Search_Tree" target="_blank">Binary Search Tree</a></p>

<p><a href="https://github.com/ayoungprogrammer/Algorithms/blob/master/src/TreeSet.java" target="_blank">Source on Github</a></p>

<p>A tree set is a set which stores the values in a <a href="./Binary_Search_Tree" target="_blank">binary search tree</a>. To store elements in a tree set, they must be able to be sorted by a property. To insert an element, it is added to the binary tree. To delete an element, it is removed from the binary tree. To check for membership, we do a binary search for the element in the binary tree.</p>

<p>The advantage of tree sets is that they are maintained in a sorted order.</p>

<p><img src="./public_html/img/uploads/bst.png"></p>

<table>
<thead>
<tr>
  <th>Operation</th>
  <th>Membership</th>
  <th>Insertion</th>
  <th>Deletion</th>
</tr>
</thead>
<tbody>
<tr>
  <td>Time Complexity</td>
  <td>O(log n)</td>
  <td>O(log n)</td>
  <td>O(log n)</td>
</tr>
</tbody>
</table>

</section><section><h2>Implementation</h2>

<p>Tree Sets are implemented using <a href="./Binary_Search_Tree" target="_blank">binary search trees</a>.</p>

</section><section><h2>Exercises</h2>

<ol>
<li>Given a list of names, output all the unique names in alphabetical order</li>
</ol>
</section><h1>Maps</h1><section><h2>Introduction</h2>

<p>A map is an abstract data type that stores key-value pairs.</p>

<p>Imagine you had a English dictionary. If you look up a word, you can find it's definition and read it out. For example if you looked up the word 'cat' in the English dictionary, you would look through the dictionary alphabetically until you found the word 'cat' and then you would look at the definition: 'a feline animal'. If you really wanted to, you could also add your own words into the dictionary and the definitions of your words. This type of structure is called a map.</p>

<p>Maps (also called dictionaries) are abstract data types that store pairs of key-values and can be used to look up values from the keys. The keys are like the words in an English dictionary and the definitions can be seen as the values. Maps are able to support insertion of key-value pairs, retrieve values from keys, and delete key-value pairs.</p>

<hr><h3>Prerequisites</h3>

<ul>
<li><a href="./Sets" target="_blank">Sets</a></li>
</ul>

</section><section><h2>Implementation</h2>

<table>
<thead>
<tr>
  <th>Type</th>
  <th>Get</th>
  <th>Insertion</th>
  <th>Deletion</th>
</tr>
</thead>
<tbody>
<tr>
  <td><a href="./Tree_Map" target="_blank">Tree Map</a></td>
  <td>O(log n)</td>
  <td>O(log n)</td>
  <td>O(log n)</td>
</tr>
<tr>
  <td><a href="./Hash_Map" target="_blank">Hash Map</a></td>
  <td>O(1)</td>
  <td>O(1)</td>
  <td>O(1)</td>
</tr>
</tbody>
</table>

</section><section><h2>Exercises</h2>

<ol>
<li>Given a list of N strings, output the strings in alphabetical order and the number of times they appear in the list.
2, Given two list of N strings, output the </li>
</ol>
</section><h1>Hash Map</h1><section><h2>Introduction</h2>

<p><em>Prerequisites</em>: <a href="./Map" target="_blank">Map</a>, <a href="./Hash_Set" target="_blank">Hash Set</a></p>

<p><a href="https://github.com/ayoungprogrammer/Algorithms/blob/master/src/HashMap.java" target="_blank">Source on GitHub</a></p>

<p>Hash maps are maps that use <a href="./Hash_sets" target="_blank">hash sets</a> to store the keys.</p>

</section><section><h2>Implementation</h2>

<p>Here is a Java implementation of a hash map which is a modified version of a <a href="./hash_set" target="_blank">hash set</a>.</p>

<hr><h3>Class</h3>

<p>Inside our implementation of a hash map we will store the buckets using an array of linked lists, the number of buckets, and the number of elements in the set.</p>

<p>The collision chance is the threshold for resizing the hash set. When the ratio of elements in the set to number of buckets is greater than the threshold, then the chance of collision will be high enough that it will slow down the operations. The lower this ratio, the better performing a hash set will be.</p>

<pre class="prettyprint linenums ">
public class HashMap {

    public LinkedList&lt;Pair&gt;[] buckets;
    public int bucketsSize = 10;
    public int size = 0;
    public static final double COLLISION_CHANCE = 0.3;
    
    public HashMap(){
        buckets = new LinkedList[10];
        for(int i=0;i&lt;bucketsSize;i++){
            buckets[i] = new LinkedList&lt;Pair&gt;();
        }
        size = 0;
    }
}
</pre>

<hr><h3>Hash</h3>

<p>The hash code is the result of the hashing algorithm for an element. In our hash set implementation, we will use a simple hash: modulus of the integer by the number of buckets.</p>

<p>For the most part if the numbers are all random then the hash function is fine. However, if the number of buckets was 10 and we added the elements 20,30,40,50,60,70, they will all end up in the same bucket and results in poor performance.</p>

<pre class="prettyprint linenums ">
public int getHash(int x,int hashSize){
    return x % hashSize;
}
</pre>

<hr><h3>Resize</h3>

<p>A hash map must be able to resize. When the ratio of number of elements to number of buckets, the chance of collision will increase more and more. So we must able to resize the number of buckets to support the number of elements to lower the chance of collision.</p>

<p>To resize efficiently, we can create two times the number of buckets and set them to empty and then insert all the elements in the old buckets to the new buckets.</p>

<pre class="prettyprint linenums ">
public void resize(){
    int newBucketsSize = bucketsSize*2;
    LinkedList&lt;Pair&gt;[] newBuckets = new LinkedList[newBucketsSize];
    for(int i=0;i&lt;newBucketsSize;i++){
        newBuckets[i] = new LinkedList&lt;Pair&gt;();
    }
    for(int i=0;i&lt;bucketsSize;i++){
        for(Pair p:buckets[i]){
            int hash = getHash(p.key,newBucketsSize);
            newBuckets[hash].push(p);
        }
    }
    buckets = newBuckets;
    bucketsSize = newBucketsSize;
}
</pre>

<hr><h3>Insert</h3>

<p>To insert an element in a hash set, we get the hash code from our hashing algorithm and insert the element into the corresponding bucket.</p>

<p>The function will return method or not the operation was successful. If the bucket already contains the element the operation will stop because we do not want to add duplicate elements into the set. If the bucket does not contain the element, we will insert it into the bucket and the operation is successful.</p>

<pre class="prettyprint linenums ">
public boolean insert(Pair p){
    int hash = getHash(p.key,bucketsSize);
    
    LinkedList&lt;Pair&gt; curBucket = buckets[hash];
    if(curBucket.contains(p.key)){
        return false;
    }
    curBucket.push(p);
    if( (float)size/bucketsSize&gt;COLLISION_CHANCE){
        resize();
    }
    size++;
    return true;
}
</pre>

<hr><h3>Get</h3>

<p>To get the value from a hash set from a key, we get the hash code from our hashing algorithm of the key and find the key-value pair in the corresponding bucket.</p>

<pre class="prettyprint linenums ">
public Pair get(int key){
    int hash = getHash(key,bucketsSize);
    LinkedList&lt;Pair&gt; curBucket = buckets[hash];
    for(Pair p:curBucket){
        if(p.key==key){
            return p;
        }
    }
    return null;
}
</pre>

<hr><h3>Remove</h3>

<p>To remove an element from a hash set, we get the hash code from our hashing algorithm and remove the element from the corresponding bucket.</p>

<p>The function will return whether or not the operation was successful. If the bucket contains the element we can remove it from the linked list and the operation is successful. If the element is not in the bucket then the operation fails because we cannot remove something that is not there.</p>

<pre class="prettyprint linenums ">
public boolean remove(int key){
    int hash = getHash(key,bucketsSize);
    
    LinkedList&lt;Pair&gt; curBucket = buckets[hash];
    for(Pair p: curBucket){
        if(p.key==key){
            curBucket.remove(p);
            return true;
        }
    }
    return false;
}
</pre>

</section><section><h2>Exercises</h2>

<ol>
<li>Create a hash map for the English dictionary (word as keys, definition as value). You will need to create a hash function for strings.</li>
</ol>
</section><h1>Tree Map</h1><section><h2>Introduction</h2>

<p>A tree map is a map that stores the key value pairs in a tree set.</p>

<table>
<thead>
<tr>
  <th>Operation</th>
  <th>Membership</th>
  <th>Insertion</th>
  <th>Deletion</th>
</tr>
</thead>
<tbody>
<tr>
  <td>Complexity</td>
  <td>O(log n)</td>
  <td>O(log n)</td>
  <td>O(log n)</td>
</tr>
</tbody>
</table>

<hr><h3>Prerequisites</h3>

<ul>
<li><a href="./Tree_Set" target="_blank">Tree Set</a></li>
<li><a href="./Map" target="_blank">Map</a></li>
</ul>

</section><section><h2>Implementation</h2>

<p>Here is a Java implementation of a tree map:</p>

<p><img src="./public_html/img/uploads/bst.png"></p>

<hr><h3>Class</h3>

<p>A pair is a key with a value. In this implementation we will use the value as a string.</p>

<pre class="prettyprint linenums ">
class Pair{
    int key;
    String value;
    public Pair(int key,String value){
        this.key = key;
        this.value = value;
    }
}
</pre>

<p>A node is a node contained in the binary search tree. The node must store the child nodes and for simplicity of the implementation, we will store the parent node as well. Each node will also have a key value pair associated with it.</p>

<pre class="prettyprint linenums ">
class Node{
    Pair pair;
    Node left;
    Node right;
    Node parent;
    public Node(Pair p){
        this.pair = p;
        this.left = null;
        this.right = null;
        this.parent = null;
    }
    public void replaceChild(Node child,Node replacement){
        if(left==child){
            left = replacement;
                if(replacement!= null){
                    replacement.parent = this;
                }
            }
            if(right==child){
                right = replacement;
                if(replacement!= null){
                    replacement.parent = this;
                }
            }
        }
    }
}
</pre>

<p>In our tree map, we will store the root node (ancestor of all nodes) and the number of numbers.</p>

<pre class="prettyprint linenums ">
public class TreeMap {

    int size;
    Node root;
    
    public TreeMap(){
        size = 0;
        root = null;
    }
}
</pre>

<hr><h3>Insert</h3>

<p>To insert a key-value pair into the tree set, we first find where the key should be. If the key already exists,</p>

<pre class="prettyprint linenums ">
public boolean insert(Pair p){
    if(root==null){
        root = new Node(p);
        return true;
    }
    Node curTree = root;        
    while(curTree != null){
        if(p.key == curTree.pair.key){
            return false;
        }else if(p.key &lt; curTree.pair.key){
            if(curTree.left == null){
                Node newTree = new Node(p);
                newTree.parent = curTree;
                curTree.left = newTree;
                return true;
            }
            curTree = curTree.left;
        }else {
            if(curTree.right == null){
                Node newTree = new Node(p);
                newTree.parent = curTree;
                curTree.right = newTree;
                return true;
            }
            curTree = curTree.right;
        }
    }
    return false;
}
</pre>

<hr><h3>Get</h3>

<p>To get the value from a key stored in a tree set, we binary search for the key and then retrieve the key-value pair located at the node.</p>

<pre class="prettyprint linenums ">
public Pair get(int key){
    Node curTree = root;
    while(curTree!=null){
        if(key==curTree.pair.key){
            return curTree.pair;
        }else if(key&lt;curTree.pair.key){
            curTree = curTree.left;
        }else{
            curTree = curTree.right;
        }
    }
    return null;
}
</pre>

<hr><h3>Remove</h3>

<p>Removing an element is a much more complex because we need to maintain the tree structure of the tree set when removing elements. First we locate the element that we want to remove. If the element is not there then the operation failed and we return false. If the element is there then are three cases we need to consider.</p>

<p><img src="./public_html/img/uploads/bst-rem.png"></p>

<p><strong>Case 1: Node is a leaf node</strong></p>

<p><img src="./public_html/img/uploads/bst-rem-case11.png"></p>

<p>If the node we want to remove is the leaf node, we can simply remove it.</p>

<p><img src="./public_html/img/uploads/bst-rem-case12.png"></p>

<p><strong>Case 2: Node has one child</strong></p>

<p><img src="./public_html/img/uploads/bst-rem-case21.png"></p>

<p>If the node we want to remove has a child, we can replace that node with its' only child.</p>

<p><img src="./public_html/img/uploads/bst-rem-case22.png"></p>

<p><strong>Case 3: Node has two children</strong></p>

<p><img src="./public_html/img/uploads/bst-rem-case31.png"></p>

<p>We need to replace the node with the <strong>rightmost</strong> of the <em>left</em> subtree or the <strong>leftmost</strong> of the <em>right</em> subtree to maintain the order.</p>

<p><img src="./public_html/img/uploads/bst-rem-case32.png"></p>

<p>It does not matter which side we pick so we will use the <strong>rightmost</strong> of the <em>left</em> subtree. First we copy the value of the rightmost of the left subtree into the node that will be deleted.</p>

<p><img src="./public_html/img/uploads/bst-rem-case33.png"></p>

<p>Then we replace the rightmost of the left subtree with its left subtree.</p>

<p><img src="./public_html/img/uploads/bst-rem-case34.png"></p>

<pre class="prettyprint linenums ">
public boolean remove(int key){
    //Get node to remove
    Node curNode = root;
    while(curNode!=null){
        if(key==curNode.pair.key){
            break;
        }else if(key&lt;curNode.pair.key){
            curNode = curNode.left;
        }else{
            curNode = curNode.right;
        }
    }
    if(curNode==null){
        return false;
    }
    //Case 1: leaf node
    if(curNode.left==null &amp;&amp; curNode.right==null){
        //if root
        if(curNode==root){
            this.root = null;
        }else{
            curNode.parent.replaceChild(curNode,null);
        }
    }
    //Case 2: one child
    else if(curNode.left==null){
        //If root
        if(curNode==root){
            root = curNode.right;
            root.parent = null;
        }else {
            curNode.parent.replaceChild(curNode,curNode.right);
        }
    }
    else if(curNode.right==null){
        //If root
        if(curNode==root){
            root = curNode.left;
            root.parent = null;
        }else {
            curNode.parent.replaceChild(curNode,curNode.left);
        }
    }
    //Case 3: two children
    else {
        //Get rightmost of left subtree
        Node rightmost = curNode.left;
        while(rightmost.right!=null){
            rightmost = rightmost.right;
        }
        curNode.pair = rightmost.pair;
        rightmost.parent.replaceChild(rightmost, rightmost.left);
    }
    size--;
    return true;
}
</pre>

</section><section><h2>Exercises</h2>

<ol>
<li>Given a list of N numbers, output the first M unique numbers.</li>
</ol>
</section><h1>Priority Queue</h1><section><h2>Introduction</h2>

<p><em>Prerequisites</em>: <a href="./Queue" target="_blank">Queue</a>, <a href="./Heap" target="_blank">Heap</a></p>

<p>Consider a waiting list for lung donors. The patients are given a score when they are placed on the waiting list by how much they need a lung based on their whether they smoke, risk factors, age, expected time left etc. When a lung is available, the patient with the highest score will get removed from the waiting list. During this time, more patients could be added to the queue. The behaviour is similar to a queue but instead of the first person getting in the queue getting a lung first, the person with the highest score will get it. This means that if Sam has a score of 60 and gets placed in the queue after Bob who has a score of 40, Sam will get the lung first even though Bob was in the queue before him.</p>

<p>A <strong>priority queue</strong> is an abstract data structure with two operations: push and pop. Push adds an element into the priority queue and pop removes the highest or lowest element.</p>

<p>A priority queue is usually implemented as a heap because it is the most efficient because of its structure.</p>

</section><section><h2>Implementation</h2>

<table>
<thead>
<tr>
  <th>Implementation</th>
  <th>Push</th>
  <th>Pop</th>
</tr>
</thead>
<tbody>
<tr>
  <td><a href="./Heap" target="_blank">Heap</a></td>
  <td>O(log n)</td>
  <td>O(log n)</td>
</tr>
</tbody>
</table>

</section><section><h2>Applications</h2>

<p>Priority queues are very efficient in its opertions O(log n) and it is used in many other algorithms such as:</p>

<ul>
<li><a href="./Dijkstra's" target="_blank">Dijkstra's</a></li>
<li><a href="./Prim's" target="_blank">Prim's</a></li>
<li><a href="./Kruskal" target="_blank">Kruskal</a></li>
<li><a href="./Line_Sweeping" target="_blank">Line Sweeping</a></li>
</ul>

</section><section><h2>Exercises</h2>

<ol>
<li>Given a list of N numbers, find the M largest numbers. (Note you can do better than O(N log N))</li>
<li>Given N lists of N numbers, find the N largest numbers.</li>
</ol>
</section><h1>Heap</h1><section><h2>Introduction</h2>

<p><strong>Prerequisites</strong>: <a href="./Queue" target="_blank">Queue</a></p>

<p><a href="https://github.com/ayoungprogrammer/Algorithms/blob/master/src/PQueue.java" target="_blank">Source on GitHub</a></p>

<p>Heaps are data structures that are able to pop the maximum or minimum value or push a value very quickly. Heaps are implemented as trees which have the property that a parent node must either be greater than all the elements in its left and right subtrees (a max heap) or less than all the elements in its left and right subtrees (a min heap). <a href="./Priority_Queue" target="_blank">Priority queue's</a> are most efficiently implemented as heaps. This guarantees that the maximum or minimum element is the root node.</p>

<p>Heaps store their data level by level in a binary tree. This allows us to store heaps in an array. The root index is 0. For every node, the left index can be found by using the formula 2&#42;ind+1 and the right index can be found by using the formula 2&#42;ind + 2. The parent of a node can be found by integer division with (ind-1)/2.</p>

<pre class="prettyprint linenums lang-html">
root = 0
left = index * 2 + 1
right = index * 2 + 2
parent = (index-1)/2
</pre>

<p>Indexes of a heap</p>

<p><img src="./public_html/img/uploads/maxheap2.png"></p>

<p>Example Heap:</p>

<p><img src="./public_html/img/uploads/maxheap.png"></p>

<p>A heap has two operations: push and pop. Pushing an element into a heap adds it into the heap and the heap needs to ensure that the properties of the heap still hold. Popping removes an element from the top of the heap and the heap needs to ensure that the properties of the heap still hold.</p>

<table>
<thead>
<tr>
  <th>Operation</th>
  <th>Heapify</th>
  <th>Resize</th>
  <th>Push</th>
  <th>Pop</th>
</tr>
</thead>
<tbody>
<tr>
  <td>Time Complexity</td>
  <td>O(n)</td>
  <td>O(n)</td>
  <td>O(log n)</td>
  <td>O(log n)</td>
</tr>
</tbody>
</table>

</section><section><h2>Implementation</h2>

<p>Here is an implementation of a max heap. A heap needs to be able to resize, push an element and pop an element.</p>

<hr><h3>Class</h3>

<pre class="prettyprint linenums ">
public class Heap {

    public int[] arr;
    public int size;
    
    public Heap(int startSize){
        arr = new int[startSize];
        size = 0;
    }
}
</pre>

<hr><h3>Heapify</h3>

<p>Heapify takes a random array of N elements and transforms it into a heap. The runtime of heapify is O(N).</p>

<pre class="prettyprint linenums ">
public void heapify(int arr[]){
    this.arr = arr;
    for(int i=0;i&lt;Math.floor(arr.length/2.0);i++){
        int idx = i;
        while(idx&lt;size){
            int left = idx*2+1;
            int right = idx*2+2;
            if(left&lt;size &amp;&amp; arr[left]&gt;arr[idx]){
                int swap = arr[left];
                arr[left] = arr[idx];
                arr[idx] = swap;
                idx = left;
            }else if(right&lt;size &amp;&amp; arr[right]&gt;arr[idx]){
                int swap = arr[right];
                arr[right]=arr[idx];
                arr[idx] = swap;
                idx = right;
            }else {
                break;
            }
        }
    }
}
</pre>

<hr><h3>Resize</h3>

<p>When the heap gets too full, we can resize it to make it bigger</p>

<pre class="prettyprint linenums ">
public void resize(){
    int[] newArr = new int[arr.length*2];
    for(int i=0;i&lt;size;i++){
        newArr[i] = arr[i];
    }
    arr = newArr;
}
</pre>

<hr><h3>Push</h3>

<p>Pushes the number x into the priority queue. We can do this by adding it to the bottom of the heap and then keep swapping it upwards if it is greater than the parent.</p>

<p><img src="./public_html/img/uploads/maxheap.png"></p>

<p><img src="./public_html/img/uploads/maxheappush.png"></p>

<p><img src="./public_html/img/uploads/maxheappush2.png"></p>

<p><img src="./public_html/img/uploads/maxheappush3.png"></p>

<pre class="prettyprint linenums ">
public void push(int x){
        
    if(size&gt;=arr.length){
        resize();
    }
    arr[size] = x;
    size++;
    
    //Make sure parent is &gt; child from the last element
    int idx = size-1;
    int parent = (idx-1)/2;
    while(idx&gt;0 &amp;&amp; arr[parent]&lt;arr[idx]){
        int swap = arr[parent];
        arr[parent] = arr[idx];
        arr[idx] = swap;
        idx = parent;
        parent = (idx-1)/2;
    }
}
</pre>

<hr><h3>Pop</h3>

<p>Popping removes the greatest element in the priority queue by removing the root which is guaranteed to be the greatest as property of a heap. After removing the root, we replace it with the element at the bottom of the heap and we can keep swapping it with its children until the heap property is satisfied.</p>

<p><img src="./public_html/img/uploads/maxheappop.png"></p>

<p><img src="./public_html/img/uploads/maxheappop1.png"></p>

<p><img src="./public_html/img/uploads/maxheappop2.png"></p>

<p><img src="./public_html/img/uploads/maxheappop3.png"></p>

<pre class="prettyprint linenums ">
public int pop(){
    if(size==0)return 0;
    int ret = arr[0];
    arr[0] = arr[size-1];
    size--;
        
    int idx = 0;
        
    while(idx&lt;size){
        int left = idx*2+1;
        int right = idx*2+2;
        if(left&lt;size &amp;&amp; arr[left]&gt;arr[idx]){
            int swap = arr[left];
            arr[left] = arr[idx];
            arr[idx] = swap;
            idx = left;
        }else if(right&lt;size &amp;&amp; arr[right]&gt;arr[idx]){
            int swap = arr[right];
            arr[right]=arr[idx];
            arr[idx] = swap;
            idx = right;
        }else {
            break;
        }
    }
}
</pre>

</section><section><h2>Applications</h2>

<p>Heaps are very efficient in its opertions O(log n) and it is used in many other algorithms such as:</p>

<ul>
<li><a href="./Dijkstra's" target="_blank">Dijkstra's</a></li>
<li><a href="./Prim's" target="_blank">Prim's</a></li>
<li><a href="./Kruskal" target="_blank">Kruskal</a></li>
<li><a href="./Line_Sweeping" target="_blank">Line Sweeping</a></li>
</ul>

</section><section><h2>Exercises</h2>

<ol>
<li>Implement a min heap</li>
<li>Prove heaps work</li>
</ol>
</section><h0>Graph Theory</h0><section><h3>Introduction</h3>

<p><strong>Next</strong>: <a href="./Advanced_Graph_Theory" target="_blank">Advanced Graph Theory</a></p>

<p>Graphs are a set of objects where some pairs of objects  called <strong>nodes</strong> or <strong>verticies</strong> are usually connected by links called <strong>edges</strong>. The nodes here can be seen numbered from 1 to 6. There are edges connecting these various nodes.</p>

<p><img src="./public_html/img/uploads/graph.png"></p>

<p>A <strong>undirected</strong> graph is a graph where an edge from A to B is the same as the edge from B to A for all edges. The above graph is undirected.</p>

<p>A <strong>directed</strong> or <strong>bidirectional</strong> graph is a graph where edges have direction meaning if there is an edge from A to B then there may not be an edge from B to A.</p>

<p><img src="./public_html/img/uploads/digraph.png"></p>

<p>A <strong>subgraph</strong> is a subset of edges and vertices within a graph.</p>

<p>A <strong>directed acyclic graph</strong> (DAG) is a graph with no directed cycles (see topological sorting).</p>

<p>A <strong>weighted</strong> graph is a graph that contains weights or values assigned to each edge or node. Usually these weights act as the cost to reach/use that node.</p>

</section><h1>Advanced Graph Theory</h1><section><h2>Introduction</h2>

<p><em>Prerequisites</em>: <a href="./Graph_Theory" target="_blank">Graph Theory</a></p>

<p>Advanced topics on graph theory.</p>

</section><section><h2>Bipartite Graph</h2>

<p>A bipartite graph is a graph which can be partitioned into two sets such that no nodes in a set connect to another node in the same set.</p>

</section><section><h2>Special Paths</h2>

<p>A path is a certain order of visiting objects.</p>

<hr><h3><a href="./Hamiltonian_Path" target="_blank">Hamiltonian Path</a></h3>

<p>A <a href="./Hamiltonian_Path" target="_blank">Hamiltonian Path</a> is a path that visits every node exactly once.</p>

<hr><h3><a href="./Eulerian_Path" target="_blank">Eulerian Path</a></h3>

<p>A <a href="./Eulerian_Path" target="_blank">Eulerian Path</a> is a path that visited every edge exactly once.</p>

</section><section><h2>Special Cycles</h2>

<p>A cycle is a path that ends up at the same starting position.</p>

<hr><h3><a href="./Hamiltonian_Cycle" target="_blank">Hamiltonian Cycle</a></h3>

<p>A <a href="./Hamiltonian_cycle" target="_blank">Hamiltonian cycle</a> is a cycle that visits every node exactly once at ends back at the start.</p>

<hr><h3><a href="./Eulerian_Cycle" target="_blank">Eulerian Cycle</a></h3>

<p>A <a href="./Eulerian_Cycle" target="_blank">Eulerian Cycle</a> is a cycle that visited every edge exactly once at ends back at the start.</p>

<hr><h3><a href="./Travelling_Salesman_Problem" target="_blank">Travelling Salesman Problem</a></h3>

<p>The <a href="./Travelling_salesman" target="_blank">Travelling salesman</a> is the problem where a salesman wants to find a cycle that minimizes the total cost of weights used of edges.</p>

</section><section><h2>Special Nodes</h2>

<p>Some graphs may have nodes that have special properties.</p>

<hr><h3>Root</h3>

<p>A node in a directed acyclic graph that has no ancestors is a root.</p>

<p><img src="./public_html/img/uploads/treeroot.png"></p>

<hr><h3>Center</h3>

<p>The center of a undirected tree is the node that minimizes the sum of the distance to every other node.  The center can be found be continuously stripping away leaf nodes (nodes with only one edge) layer by layer until either 1 or 2 nodes remain. The longest path in a tree will contain the center.</p>

<p><img src="./public_html/img/uploads/centergraph.png"></p>

</section><section><h2>Network Flow</h2>

<hr><h3>Max Flow Problem</h3>

<hr><h3>Min Cut Problem</h3>

<hr><h3>Ford-Fulkerson</h3>
</section><h1>Adjacency Matrix</h1><section><h2>Introduction</h2>

<p>An adjacency matrix is a method of storing a graph using a two dimensional array. Given n nodes, the adjacency matrix can be stored in a n x n matrix.</p>

<p>Array[i][j] represents the weight between the node i and node j.</p>

<p>Example</p>

<table>
<thead>
<tr>
  <th></th>
  <th>1</th>
  <th>2</th>
  <th>3</th>
  <th>4</th>
  <th>5</th>
  <th>6</th>
</tr>
</thead>
<tbody>
<tr>
  <td>1</td>
  <td>0</td>
  <td>1</td>
  <td>0</td>
  <td>0</td>
  <td>1</td>
  <td>0</td>
</tr>
<tr>
  <td>2</td>
  <td>1</td>
  <td>0</td>
  <td>1</td>
  <td>0</td>
  <td>1</td>
  <td>0</td>
</tr>
<tr>
  <td>3</td>
  <td>0</td>
  <td>1</td>
  <td>0</td>
  <td>1</td>
  <td>0</td>
  <td>0</td>
</tr>
<tr>
  <td>4</td>
  <td>0</td>
  <td>0</td>
  <td>1</td>
  <td>0</td>
  <td>1</td>
  <td>1</td>
</tr>
<tr>
  <td>5</td>
  <td>1</td>
  <td>1</td>
  <td>0</td>
  <td>1</td>
  <td>0</td>
  <td>0</td>
</tr>
<tr>
  <td>6</td>
  <td>0</td>
  <td>0</td>
  <td>0</td>
  <td>1</td>
  <td>0</td>
  <td>0</td>
</tr>
</tbody>
</table>

</section><section><h2>Implementation</h2>

<pre class="prettyprint linenums ">
class edge{
    int weight,source,dest;
    public edge(int source,int dest,int weight){
        this.source = source;
        this.dest = dest;
        this.weight = weight;
    }
}
public static int[][] getAdjMatrix(Vector&lt;edge&gt; edges){
    int n = 0;
    int adjMatrix[][] = new int[n][n];
    
    for(int i=0;i&lt;n;i++)for(int j=0;j&lt;n;j++)adjMatrix[i][j] = 0;
    
    for(int i=0;i&lt;edges.size();i++){
        edge e = edges.get(i);
        adjMatrix[e.source][e.dest] = e.weight;
        adjMatrix[e.dest][e.source] = e.weight;
    }
    return adjMatrix;
}
</pre>
</section><h1>Prim's</h1><section><p><strong>Prerequisites</strong>:  <a href="./Priority_Queue" target="_blank">Priority Queue</a>, <a href="./Minimum_Spanning_Tree" target="_blank">Minimum Spanning Tree</a></p>

<p>A <a href="./Minimum_Spanning_Tree" target="_blank">minimum spanning tree</a> is a tree in a graph that connects all the nodes using the smallest cost total cost of edges.</p>

</section><section><h2>Implementation</h2>

<p>Prim's algorithm finds the minimum spanning tree using a greedy fashion. It works as such:</p>

<ol>
<li>Pick an arbitrary node</li>
<li>Find the closest node to that node</li>
<li>Find the closest node to the 2 nodes</li>
<li>Find the closest node to the 3 nodes</li>
<li>...</li>
<li>Find the closest node to n-1 nodes</li>
</ol>

<p>The closest node is the node with the lowest cost edge to the already connected nodes.</p>

<hr><h3>Example</h3>

<p><img src="./public_html/img/uploads/prim.png"></p>

<p><img src="./public_html/img/uploads/prim1.png"></p>

<p><img src="./public_html/img/uploads/prim2.png"></p>

<p><img src="./public_html/img/uploads/prim3.png"></p>

<p><img src="./public_html/img/uploads/prim4.png"></p>

<p><img src="./public_html/img/uploads/prim5.png"></p>

<p><img src="./public_html/img/uploads/prim6.png"></p>

<p><img src="./public_html/img/uploads/prim7.png"></p>

<hr><h3>Java Code</h3>

<p>In Java, we need to specify a comparison for the Priority Queue to order. We do this by implementing the Comparable class and overriding the compareTo method.</p>

<p>adjList is an <a href="./Adjacency_List" target="_blank">adjacency list</a> that is an array of arrays that store the graph.</p>

<pre class="prettyprint linenums ">

class node implements Comparable&lt;node&gt;{
    int weight,index;
    public node(int weight,int index){
        this.weight = weight;
        this.index = index;
    }
    public int compareTo(node e){
        return weight-e.weight;
    }
}
public static int Prims(Vector&lt;Vector&lt;node&gt;&gt; adjList){
    int cost = 0;
    int n = adjList.size();
    PriorityQueue&lt;node&gt; pq = new PriorityQueue&lt;node&gt;();
    boolean visited[] = new boolean[n];
    for(int i=0;i&lt;n;i++){
        visited[i] = false;
    }
    int inTree = 1;
    visited[0] = true;
    for(int i=0;i&lt;adjList.get(0).size();i++){
        pq.add(adjList.get(0).get(i));
    }
    while(!pq.isEmpty()&amp;&amp;inTree&lt;n){
        node cur = pq.poll();
        if(visited[cur.index])continue;
        inTree++;
        visited[cur.index]=true;
        cost+=cur.weight;
        for(int i=0;i&lt;adjList.get(cur.index).size();i++){
            pq.add(adjList.get(cur.index).get(i));          
                 }
    }
    //Graph is not connected
    if(inTree&lt;n)return -1;
    return cost;
}
</pre>

</section><section><h2>Applications</h2>

<p>In networking, if a cable company wanted to connect all the houses with the least amount of wiring, the minimum spanning tree can be found that finds the least total cost of wire.</p>

<p>Minimum spanning trees can also be used in generating mazes.</p>

</section><section><h2>Exercises</h2>

<ol>
<li>Prove that Prim's algorithm works</li>
<li>Extends Prim's to output all the edges used</li>
<li>Given a weighted graph with n nodes, find the smallest total cost to connect all nodes into 3 separate groups. (A single node can be a group)</li>
<li>Same as 3, but a group must contain at least 3 other nodes.</li>
</ol>
</section><h1>Kruskal</h1><section><h2>Introduction</h2>

<p><strong>Prerequisites</strong>:  <a href="./Sorting" target="_blank">Sorting</a>, <a href="./Minimum_Spanning_Tree" target="_blank">Minimum Spanning Tree</a></p>

<p>A <a href="./Minimum_Spanning_Tree" target="_blank">minimum spanning tree</a> is a tree in a graph that connects all the nodes using the smallest cost total cost of edges.</p>

<p>Kruskal's algorithm finds the <a href="./Minimum_Spanning_Tree" target="_blank">minimum spanning tree</a> using <a href="./Connected_Components" target="_blank">connected components</a>.</p>

<p>If implemented efficiently using a priority queue to get the edges with minimum weight or a sorting the edges, the runtime is O(n log n).</p>

</section><section><h2>Implementation</h2>

<ol>
<li>Uniquely label each node</li>
<li>Take the edge with the minimum weight</li>
<li>If the edge connects nodes A and B with different labels, all nodes with label B will be labeled with A. Otherwise, throw the edge away</li>
<li>Repeat 2-3 until all the nodes have the same label</li>
</ol>

<hr><h3>Example</h3>

<p><img src="./public_html/img/uploads/kruskal.png"></p>

<p><img src="./public_html/img/uploads/kruskal2.png"></p>

<p><img src="./public_html/img/uploads/kruskal3.png"></p>

<p><img src="./public_html/img/uploads/kruskal4.png"></p>

<p><img src="./public_html/img/uploads/kruskal5.png"></p>

<p><img src="./public_html/img/uploads/kruskal6.png"></p>

<p><img src="./public_html/img/uploads/kruskal7.png"></p>

<hr><h3>Code</h3>

<pre class="prettyprint linenums ">
class edge implements Comparable&lt;edge&gt;{
    int weight,source,dest;
    public edge(int source,int dest,int weight){
        this.source = source;
        this.dest = dest;
        this.weight = weight;
    }
    public int compareTo(edge e){
        return weight-e.weight;
    }
}
public static int getParent(int parents[],int x){
    if(parents[x]==x)return x;
    parents[x] = getParent(parents,parents[x]);
    return parents[x];
}
public static int Kruskal(Vector&lt;Vector&lt;edge&gt;&gt; adjList){
    int n = adjList.size();
    int parents[] = new int[n];
    for(int i=0;i&lt;n;i++)parents[i] = i;
    int sum = 0;
    
    PriorityQueue&lt;edge&gt; edges = new PriorityQueue&lt;edge&gt;();
    
    for(int i=0;i&lt;n;i++){
        for(int j=0;j&lt;adjList.get(i).size();j++){
            edges.add(adjList.get(i).get(j));
        }
    }
    
    while(!edges.isEmpty()){
        edge e = edges.poll();
        if(getParent(parents,e.source)!=getParent(parents,e.dest)){
            parents[e.source] = getParent(parents,e.dest);
            sum+=e.weight;
        }
    }
    
    return sum;
}
</pre>

</section><section><h2>Applications</h2>

</section><section><h2>Exercises</h2>

<ol>
<li>Prove Kruskal's Algorithm works</li>
<li>Extends Kruskals's to output all the edges used</li>
<li>Given a weighted graph with n nodes, find the smallest total cost to connect all nodes into 3 separate groups. (A single node can be a group)</li>
<li>Same as 3, but a group must contain at least 3 other nodes.</li>
</ol>
</section><h1>Floyd Warshall</h1><section><h2>Introduction</h2>

<p><strong>Prerequisites</strong>:  <a href="./Shortest_Path" target="_blank">Shortest Path</a>, <a href="./Dynamic_Programming" target="_blank">Dynamic Programming</a></p>

<p>Floyd Warshall is a algorithm for finding the shortest distances between all pairs of nodes in a graph. Floyd Warshall can be used to find negative cycles in the graph.</p>

<table>
<thead>
<tr>
  <th>Description</th>
  <th>Time</th>
  <th>Space</th>
  <th>Detect cycles?</th>
</tr>
</thead>
<tbody>
<tr>
  <td>Computes shortest path between all pairs of nodes</td>
  <td>O(n<sup>3</sup>)</td>
  <td>O(n<sup>2</sup>)</td>
  <td>Yes</td>
</tr>
</tbody>
</table>

</section><section><h2>Implementation</h2>

<p>Floyd-Warshall uses a <a href="./Dynamic_Programming" target="_blank">dynamic programming</a> approach to finding the shortest path between node A and node B. Every path from node A to node B can be rewritten as a path from A to some node in between plus the path from the node in between to node B. The shortest path from A to B can be found by finding a node C such the shortest path from A to C plus the shortest path from C to B is minimized.</p>

<p><img src="./public_html/img/uploads/floydwarshall1.png"></p>

<p><img src="./public_html/img/uploads/floydwarshall.png"></p>

<hr><h3>Formalization</h3>

<p>Recursion</p>

<pre class="prettyprint linenums ">
Given a directed graph with N nodes and edges between nodes:
Let edge(i,j) be the weight of the edge from node i to node j in the graph
Let shortestPath(i,j) be the shortest path from i to j

Base Case:
shortestPath(i,i) = 0
shortestPath(i,j) = edge(i,j)

Recursion:
shortestPath(i,j) =  minmum of shortestPath(i,k) + shortestPath(k,j) for all unvisited nodes k
</pre>

<hr><h3>Code</h3>

<pre class="prettyprint linenums ">
class edge{
    int weight,source,dest;
    public edge(int source,int dest,int weight){
        this.source = source;
        this.dest = dest;
        this.weight = weight;
    }
}
public static final int UNDEFINED = Integer.MIN_VALUE;
    
public static int[][] FloydWarshall(Vector&lt;Vector&lt;edge&gt;&gt; adjList){
    int n = adjList.size();
    //dist[i][j] is the minimum distance from i to j
    int[][] dist = new int[n][n];
    
    //initialize dist[i][j]
    for(int i=0;i&lt;n;i++){
        for(int j=0;j&lt;n;j++){
            dist[i][j] = UNDEFINED;
        }
    }
    
    //dist[i][i] = 0
    for(int i=0;i&lt;n;i++){
        dist[i][i]=0;
    }
    
    //initialize weights, dist[i][j] = edge from i to j
    for(int i=0;i&lt;n;i++){
        for(int j=0;j&lt;adjList.get(i).size();j++){
            
            edge e = adjList.get(i).get(j);
            dist[e.source][e.dest] = e.weight;
            
            System.out.println(e.source+" "+e.dest);
        }
    }
    
    for(int k=0;k&lt;n;k++){
        for(int i=0;i&lt;n;i++){
            for(int j=0;j&lt;n;j++){
                //If dist[i][k] and dist[k][j] have been set then use those values
                if(dist[i][k]!=UNDEFINED&amp;&amp;dist[k][j]!=UNDEFINED){
                    //If the new distance is less than current or not used, then update
                    int newDist = dist[i][k]+dist[k][j];
                    if(dist[i][j] &gt; newDist || dist[i][j]==UNDEFINED){
                        dist[i][j] = newDist;
                    }
                }
            }
        }
    }
    for(int i=0;i&lt;n;i++){
        if(dist[i][i]&lt;0){
            System.out.println("negative cycle");
        }
    }
    
    return dist;
}
</pre>

</section><section><h2>Applications</h2>

<p>Floyd Warshall is useful when you want to find the shortest distance between all possible pairs of nodes.</p>

</section><section><h2>Exercises</h2>

<ol>
<li>Prove Floyd Warshall works</li>
<li>Extend Floyd Warshall to reconstruct the paths from each pair of nodes</li>
</ol>
</section><h1>Bellman Ford</h1><section><h2>Introduction</h2>

<p><strong>Prerequisites</strong>:  <a href="./Shortest_Path" target="_blank">Shortest Path</a></p>

<p>Bellman Ford is an algorithm that finds the shortest path from one source node to every other node in the graph. The running time is O(n<sup>2</sup>) and is slower than <a href="./Dijkstra's" target="_blank">Dijkstra's</a> but it is able to find negative cycles.</p>

</section><section><h2>Implementation</h2>

<p>Bellman Ford can be done using <a href="./Backtracking" target="_blank">backtracking</a> to find the shortest path in a graph. We first start at the starting node with starting cost of 0 and 0 edges used. For each node thats connected to that node, we repeat and add to the cost of the node.</p>

<p><img src="./public_html/img/uploads/bellmanford.png"></p>

<p>We will do an example of the Bellman Ford algorithm on the above graph. At each node we have the node index and the current weight to reach that node. We start at node 0 with a weight of 0.</p>

<p><img src="./public_html/img/uploads/bellmanford2.png"></p>

<p>From node 0, we can reach node 1 and node 3. At node 1, we have an accumulative weight of 3. At node , we have an accumulative weight of 5.</p>

<p><img src="./public_html/img/uploads/bellmanford3.png"></p>

<p>From node 1, we can reach node 2 and node 4 with respective accumulative weights of 10 and 5.</p>

<p>From node 3 we can reach node 4 with an accumulative weight of 9.</p>

<p><img src="./public_html/img/uploads/bellmanford4.png"></p>

<p>From node 2, we can reach node 5 with an accumulative weight of 19.</p>

<p>From node 4, we can reach node 5 with an accumulative weight of 11.</p>

<p>From node 4, we can reach node 5 with an accumulative weight of 15.</p>

<p><img src="./public_html/img/uploads/bellmanford5.png"></p>

<pre class="prettyprint linenums lang-html">
Let N be the number of nodes in the graph
Let edges an adjacency list of the graph where:
    edges[source] contains all edges of the graph where source is the source edge
An edge is represented as an object where:
    edge.weight is the weight of the edge
    edge.target is the target node of the edge
    edge.source is the source node of the edge
Let start be the starting node
Let shortestPath[target] be the shortest path from the source node to the target node

Let bellmanFord(target,n,w) be the shortest path from the source node to the target node using n edges and cost of w.

bellmanFord(target, n , w)

Base Case:
bellmanFord(target, N , w):
    stop

Recurrence:
bellmanFord(source, n, w):
    shortestPath[source] = min(shortestPath[source], w)
    bellmanFord(edge.dest, n + 1, w + edge.weight) for edge in edges[source]

Init:
shortestPath = [0] * N
bellmanFord(start,0,0)
</pre>

<p>We can rewrite this solution using dynamic programming without recursion.</p>

<pre class="prettyprint linenums ">
class edge{
    int weight,source,dest;
    public edge(int source,int dest,int weight){
        this.source = source;
        this.dest = dest;
        this.weight = weight;
    }
}

public static int BellmanFord(Vector&lt;Vector&lt;edge&gt;&gt; adjList,int startNode,int endNode){
    
    int n = adjList.size();
    //dist[i] is minimum distance from start to i
    int[] dist=new int[n];
    
    //used[i] is if dist[i] has been initialized
    boolean[] used = new boolean[n];
    
    //initialize dist[i]=0 and used[i]=false
    for(int i=0;i&lt;n;i++){
        dist[i] = 0;
        used[i] = false;
    }
    used[startNode] = true;
    dist[startNode] = 0;
    for(int i=0;i&lt;n-1;i++){
        //Iterate through adjacency list
        for(int j=0;j&lt;n;j++){
            for(int k=0;k&lt;adjList.get(j).size();k++){
                if(!used[j])continue;
                edge e = adjList.get(j).get(k);
                //If dist[e.source] has been used
                if(used[e.source]){
                    //If new dist &lt; cur dist or not used, then update
                    int newDist = dist[e.source]+e.weight;
                    if(newDist&lt;dist[e.dest] || !used[e.dest]){
                        used[e.dest]= true; 
                        dist[e.dest] = newDist;
                    }
                }
            }
        }
    }
    
    for(int j=0;j&lt;n;j++){
        for(int k=0;k&lt;adjList.get(j).size();k++){
            edge e = adjList.get(j).get(k);
            //If negative cycle
            if(dist[e.source]+e.weight &lt; dist[e.dest]){
                System.out.println("Negative cycle");
            }
        }
    }
    
    //If no path exists
    if(!used[endNode]){
        System.out.println("No path from start to end");
    }
    
    //Return distance from start to end
    return dist[endNode];
}

</pre>

</section><section><h2>Applications</h2>

<p>Arbitrage occurs when you can exchange currencies for another and make a profit. For example given a currency exchange table:</p>

<table>
<thead>
<tr>
  <th></th>
  <th>USD</th>
  <th>CAD</th>
  <th>EURO</th>
</tr>
</thead>
<tbody>
<tr>
  <td>USD</td>
  <td>/</td>
  <td>1.12</td>
  <td>0.72</td>
</tr>
<tr>
  <td>CAD</td>
  <td>0.90</td>
  <td>/</td>
  <td>0.64</td>
</tr>
<tr>
  <td>EURO</td>
  <td>1.38</td>
  <td>1.56</td>
  <td>/</td>
</tr>
</tbody>
</table>

<p>Notice that 1 USD -&gt; 1.12 CAD -&gt; 1.008 USD. Bellman Ford can be used to find methods of arbitrage by using the vertex as currency and edges as transactions, and the weight as the exchange rate. All that is needed is to find a path that maximizes product of weights and finding a negative cycle.</p>

</section><section><h2>Exercises</h2>

<ol>
<li>Write a program that detects a path for arbitrage to occur</li>
<li>Prove Bellmand-Ford works</li>
</ol>
</section><h1>Dijkstra's</h1><section><h2>Introduction</h2>

<p><strong>Prerequisites</strong>:  <a href="./Shortest_Path" target="_blank">Shortest Path</a>, <a href="./Priority_Queue" target="_blank">Priority Queue</a>, <a href="./Greedy_Algorithm" target="_blank">Greedy Algorithm</a></p>

<p>Dijkstra's is a greedy approach to find the shortest path in a graph with positive weights. It has many useful applications in networking and it can be extended to a variety of problems.</p>

<p>Dijkstra works by beginning at the starting node repeatedly picking the next closest node of those already visited.</p>

<p>If Dijkstra's is implemented using a priority queue, the run time is O(n log n).</p>

<p>If a negative cycle exists within the graph, then the algorithm breaks as it will repeatedly try to take the negative edges. See <a href="./Bellman_Ford" target="_blank">Bellman Ford</a> to find negative cycles in a graph.</p>

<p>A naive fix for negative cycles would be to offset all edges by the largest negative edge and then subtract it from the resulting total but this does not work. Consider an example where you have start node A and end node B. The first route from A-&gt;B has length 2 and the second route has lengths 1,1,-2. Clearly the second route has less cost. If we try to make the length positive by adding all costs by 2, we will have the first path of length 4 and the second path of lengths 3,3,0 and the first route becomes the smallest total cost which is wrong.</p>

</section><section><h2>Implementation</h2>

<p>At each node we visit we keep track of the minimum cost it takes to reach to reach that node from the starting node.</p>

<ol>
<li>Start at the starting node</li>
<li>Find an unvisited node that has the least cost to reach from the visited nodes.</li>
<li>Mark that node as visited</li>
<li>Repeat until all nodes are visited</li>
</ol>

<p>When we reach a node for the first time, it will be the shortest path to that node (Try to prove this to yourself).</p>

<p>We first start at the starting node. The distance from the starting node to the starting node is obviously 0.</p>

<p><img src="./public_html/img/uploads/djikstra.png"></p>

<p>From the starting node we have two nodes we can reach. The top node has a cost of 3 to reach and the bottom node has a cost of 5 to reach.</p>

<p><img src="./public_html/img/uploads/djikstra1.png"></p>

<p>We pick the smallest node the reach and we mark it as visited. Once we visit a node, we can guarantee that it is the smallest cost to reach it. The next nodes minimum cost to reach is 10, 5 and 5.</p>

<p><img src="./public_html/img/uploads/djikstra2.png"></p>

<p>We are indifferent to both 5's as they are both the minimum and we can choose either. We mark the node as visited and we find the minimum costs to other nodes which are 5,10,11.</p>

<p><img src="./public_html/img/uploads/djikstra3.png"></p>

<p>We take the next smallest which is 5 and we mark the node as visited. The next costs are 10 and 11.</p>

<p><img src="./public_html/img/uploads/djikstra4.png"></p>

<p>We take the smallest which is 10 and we now only have one last node to reach at a cost of 11.</p>

<p><img src="./public_html/img/uploads/djikstra5.png"></p>

<p>At each node we have the minimum cost to get from the start node to each node.</p>

<p><img src="./public_html/img/uploads/djikstra6.png"></p>

<hr><h3>Java</h3>

<p>Implementation of Dijkstra in Java using a <a href="./Priority_Queue" target="_blank">priority queue</a>.</p>

<pre class="prettyprint linenums ">
class node implements Comparable&lt;node&gt;{
    int weight,index;
    public node(int weight,int index){
        this.weight = weight;
        this.index = index;
    }
    public int compareTo(node e){
        return weight-e.weight;
    }
}

public static int dijkstra(int[][] adjMatrix,int start,int end){
    int n = adjMatrix.length;
    PriorityQueue &lt;node&gt; pq = new PriorityQueue&lt;node&gt;();
    boolean visited[] = new boolean[n];
    for(int i=0;i&lt;n;i++)visited[i] = false;
    pq.add(new node(0,start));
    while(!visited[end] &amp;&amp; !pq.isEmpty()){
        node curNode = pq.poll();
    
        if(visited[curNode.index])continue;
        visited[curNode.index] = true;
        if(curNode.index==end){
            return curNode.weight;
        }
        for(int i=0;i&lt;n;i++){
            if(adjMatrix[curNode.index][i]&gt;0 &amp;&amp; !visited[i]){
                int newWeight = curNode.weight+adjMatrix[curNode.index][i];
                pq.add(new node(newWeight,i));
            }
        }
    }
    return -1;
}
</pre>

</section><section><h2>Applications</h2>

<p>In general, Dijkstra is usually the goto method for finding the minimum cost between two nodes in any kind of network. For example, Dijkstra can be used in networking to find the shortest path between two hosts. It can also be used in flight networking to find the cheapest cost to get from one airport to another airport.</p>

</section><section><h2>Practice Exercises</h2>

<ol>
<li>Extend Dijkstra's to find the exact path from start to end (the order of nodes of the shortest path A-&gt;B-&gt;C)</li>
<li>Extend Dijkstra's to find the best three minimal costs with unique paths from the start node to the end node</li>
<li>Prove that Dijkstra's algorithm works</li>
</ol>
</section><h1>Cycle detection</h1><section><h2>Introduction</h2>

<p>A cycle occurs in a graph when a duplicate node is encountered when traversing a tree using a <a href="./Depth_First_Search" target="_blank">depth first search</a>. In other words, a cycle occurs when you can reach the same node again.</p>

<p>An undirected graph where the number of edges is greater than or equal to the number of nodes will always have cycles.</p>

</section><section><h2>Implementation</h2>

<pre class="prettyprint linenums ">
public static boolean hasCycle(int [][] adjMatrix){
        int[] visited = new int[adjMatrix.length];
        for(int i=0;i&lt;adjMatrix.length;i++)visited[i] = 0;
        for(int i=0;i&lt;adjMatrix.length;i++){
            if(hasCycleAt(adjMatrix,i,visited))return true;
        }
        return false;
    }
    
    public static boolean hasCycleAt(int[][] adjMatrix,int i, int visited[]){
        if(visited[i] == 1)return true;
        visited[i] = 1;
        for(int j = 0; j &lt; adjMatrix.length;i++){
            if(adjMatrix[i][j] &gt; 0){
                if(hasCycleAt(adjMatrix,j,visited))return true;
                visited[j] = 0;
            }
        }
        visited[i] = 2;
        return false;
    }
</pre>
</section><h1>Topological Sorting</h1><section><h2>Introduction</h2>

<p>A topological sort or topological order of a directed graph is an order in which every node will come after its ancestors.</p>

<p><img src="./public_html/img/uploads/topsort.png"></p>

<p>For example topological orders could be:</p>

<ul>
<li>(A, B, C, D, E, F, G)</li>
<li>(B, A, D, C, F, E, G)</li>
<li>(B, A, D, G, F, C, E)</li>
</ul>

<p>But (B, A, C, F, D, E, G) is not a topological ordering because D is an ancestor of F and it comes after F.</p>

<hr><h3>Prerequisites</h3>

<ul>
<li><a href="./Graph_Theory" target="_blank">Graph Theory</a></li>
<li><a href="./Depth_First_Search" target="_blank">Depth First Search</a></li>
</ul>

</section><section><h2>Implementation</h2>

<p>Topological sort can implemented in O(n) time using DFS for a directed acyclic graph (a digraph with no cycles). How it works:</p>

<ol>
<li>Start with an empty top order</li>
<li>Pick any unmarked node</li>
<li>Get the DFS preordering from that node for unvisited nodes </li>
<li>Add the DFS to the head of the current order</li>
<li>Mark every node that has been visited</li>
</ol>

<p><img src="./public_html/img/uploads/topsort.png"></p>

<p>Example:</p>

<ul>
<li>Pick C</li>
<li>DFS preorder from C is (C,E)</li>
<li>Add DFS preorder to head [C,E]</li>
<li>Pick F</li>
<li>DFS preorder from F is (F)</li>
<li>Add DFS preorder from F to head [F,C,E]</li>
<li>Pick B</li>
<li>DFS preorder from B is (B,D,G)</li>
<li>Add DFS preorder from B to head [B,D,G,F,C,E]</li>
<li>Pick A</li>
<li>DFS preorder from A is (A)</li>
<li>Add DFS preorder from A to head [A,B,D,G,F,C,E]</li>
<li>Done, all nodes visited</li>
</ul>

<p>A DFS order from a node is guaranteed to be a topological order. Since we add everything to the head of the order, a child of a node cannot appear before it.</p>
</section><h1>Connected Components</h1><section><h2>Introduction</h2>

<p>A connected component is a subgraph where all the vertices in the subgraph connect to each other.</p>

<p>Finding the number of distinct connected components can be done using a <a href="./Breadth_First_Search" target="_blank">breadth first search</a> or a <a href="./Depth_First_Search" target="_blank">depth first search</a>.</p>

</section><section><h2>Implementation</h2>

<ol>
<li>Set each node's parent to itself</li>
<li>Pick an unused edge in the graph that is from node A to node B, if the parent of A is not the same as parent of B then set all nodes whose parent is B to parents of A</li>
<li>Repeat for all edges</li>
</ol>

<hr><h3>Example</h3>

<p><img src="./public_html/img/uploads/connectedcomponents.png"></p>

<p>We select a random edge from node 1 and node 2. We set the parent node of 2 to node 1.</p>

<p><img src="./public_html/img/uploads/connectedcomponents2.png"></p>

<p>We select another random edge from node 5 to node 6.</p>

<p><img src="./public_html/img/uploads/connectedcomponents3.png"></p>

<p>We pick another random edge and we set the parent to 5.</p>

<p><img src="./public_html/img/uploads/connectedcomponents4.png"></p>

<p>We take another random edge and we set the parents to 7.</p>

<p><img src="./public_html/img/uploads/connectedcomponents5.png"></p>

<p>We take another random edge and we have an interesting case, two connected components are to be connected. We take all the nodes whose parent is 1, and we set the new parent to 5.</p>

<p><img src="./public_html/img/uploads/connectedcomponents6.png"></p>

<p>We take another random edge and set its parent to 1.</p>

<p><img src="./public_html/img/uploads/connectedcomponents7.png"></p>

<p>We take the last edge and set the last node parent to 7.</p>

<p><img src="./public_html/img/uploads/connectedcomponents8.png"></p>

<hr><h3>Java Code</h3>

<pre class="prettyprint linenums ">
public static int getParent(int x,int[] parent){
    if(parent[x]==x)return x;
    parent[x] = getParent(parent[x],parent);
    return parent[x];
}
    
public static void connected(int adjMatrix[][]){
    int n = adjMatrix.length;
    int[] parent = new int[n];
    int i,j;
    for(i=0;i&lt;n;i++){
        parent[i] = i;
    }
    for(i=0;i&lt;n;i++){
        for(j=0;j&lt;n;j++){
            if(adjMatrix[i][j]&gt;0){
                int pi = getParent(i,parent);
                int pj = getParent(j,parent);
                if(pi!=pj){
                    parent[pj] = pi;
                }
            }
        }
    }   
}
</pre>
</section><h0>Searches</h0><section><h3>Introduction</h3>

<p>Searches are used to find solutions to problems and there many ways to search for a solution. Here are some generic searches that can be applied to many different problems.</p>

</section><h1>Binary Search</h1><section><h2><a href="./Binary_Search" target="_blank">Binary Search</a></h2>

<p>Binary search is a type of search that is able to find an object in a sorted list in O(log n). In binary search we first start at the middle element and we keep trying to halve the problem until we find the number.</p>

<p><img src="./public_html/img/uploads/binarysearch.png"></p>

<hr><h3>Example</h3>

<p>For example if I told you I had a number form 1 to 100 and I told you if your guess was higher or lower than my number you could use binary search to find it.</p>

<p>Eg: my number = 17</p>

<ul>
<li>You guess: 50</li>
<li>I say lower.</li>
</ul>

<p>So we know that:1≤number&lt;50. Since the number is &lt;50 then we know we can eliminate all the numbers above 50. We just made the problem half as hard! The reason we picked 50 is important because it is the middle and it tells us the most information. If we picked 80 and the reply was higher it would narrow down the problem a lot, but if the reply was lower it would barely reduce the problem. Picking the middle works best because it tells us the most information if we get a "lower" or "higher" reply. So we should also guess the middle between 1 and 50.</p>

<ul>
<li>You guess: 25.</li>
<li>I say lower.</li>
</ul>

<p>So we know that 1≤number&lt;25. Once again we made the problem half as hard again. Note that at every step we will make the problem half as hard. We need to pick the next middle number which is either 12 or 13, but we are indifferent because it will still tell us the most information (unless you get lucky).</p>

<ul>
<li>You guess 13.</li>
<li>I say higher.</li>
</ul>

<p>So we know that 13&lt;number&lt;25.</p>

<ul>
<li>You guess 19.</li>
<li>I say lower.</li>
</ul>

<p>So we know that 13&lt;number&lt;19.</p>

<ul>
<li>You guess 16.</li>
<li>I say higher.</li>
</ul>

<p>So we know that 16&lt;number&lt;19</p>

<ul>
<li>You guess 17.</li>
<li>I say correct!</li>
</ul>

</section><section><h2>Implementation</h2>

<p>This is a generic implementation of a binary search.</p>

<hr><h3>Generic Binary Search</h3>

<pre class="prettyprint linenums ">
void binarySearch(int ans,int minBound,int maxBound){
    while(maxVal&gt;=minVal){
       int mid = (minVal+maxVal)/2;
       if(mid==ans)return;
       if(mid&lt;ans)minVal = mid;
       else maxVal = mid;
    }
}
</pre>

</section><section><h2>Exercises</h2>

<ol>
<li>Given a sorted array, find whether or not the number N exists</li>
<li>Given a sorted array, find the the number of elements between the number A and number B inclusive.
Example: 1,2 4, 6, 8, 10, 16, 20. Given A=5 and B=15, the number of elements between A and B is 3 (6, 8, 10)</li>
<li>Given two sorted arrays, find the number of duplicate elements.</li>
<li>Given two decimal numbers A and B, how do you find A/B without using division?</li>
</ol>
</section><h1>Ternary Search</h1><section><h2>Introduction</h2>

<p>Ternary search is a search that find local minimum or maximum values in a function given the interval between A and B.</p>

<p>If there are multiple local minimum and maximum values, ternary search will find one of them but not necessarily the maximum value of all points.</p>

<p><img src="./public_html/img/uploads/ternarysearch.png"></p>

</section><section><h2>Implementation</h2>

<p>Let's say we have a function f(x) with only one max point between A and B.</p>

<p>Let m1 by 1/3 of the way from A and B and let m2 be 2/3 of the way from B.</p>

<p><img src="./public_html/img/uploads/ternarysearch.png"></p>

<hr><h3>Proof</h3>

<p><strong>Case 1</strong> : f(m1) &lt; f(m2)</p>

<ul>
<li><p><strong>Case 1.1</strong>:  m1 &lt; m2 &lt; x</p>

<p><img src="./public_html/img/uploads/ternarycase11.png"></p></li>
<li><p><strong>Case 1.2</strong>: m1&lt;x&lt;m2</p>

<p><img src="./public_html/img/uploads/ternarycase12.png"></p></li>
<li><p>x &lt; m1 &lt; m2 is not possible.</p></li>
</ul>

<p>If f(m1) &lt; f(m2) then the max point must be in the middle third or last third.</p>

<p><img src="./public_html/img/uploads/ternarycase1.png"></p>

<p><strong>Case 2</strong>: f(m1) &gt;= f(m2)</p>

<ul>
<li><p><strong>Case 2.1</strong>: m1 &lt; x &lt; m2</p>

<p><img src="./public_html/img/uploads/ternarycase21.png"></p></li>
<li><p><strong>Case 2.2</strong>: x &lt; m1 &lt; m2</p>

<p><img src="./public_html/img/uploads/ternarycase22.png"></p></li>
<li><p>m1 &lt; m2 &lt; x is not possible</p></li>
</ul>

<p>If f(m1) &gt;= f(m2) then the max point must be in the first third or middle third.</p>

<p><img src="./public_html/img/uploads/ternarycase2.png"></p>

<hr><h3>Example</h3>

<p>Using the above proof, we can use ternary search to find the maximum point.</p>

<p><img src="./public_html/img/uploads/ternarysearch.png"></p>

<p><img src="./public_html/img/uploads/ternarysearch2.png"></p>

<p><img src="./public_html/img/uploads/ternarysearch3.png"></p>

<p><img src="./public_html/img/uploads/ternarysearch4.png"></p>

<p><img src="./public_html/img/uploads/ternarysearch5.png"></p>

<p><img src="./public_html/img/uploads/ternarysearch6.png"></p>

<p><img src="./public_html/img/uploads/ternarysearch7.png"></p>

<hr><h3>Formalization</h3>

<pre class="prettyprint linenums ">
Let f(x) be the function 
Let A,B be interval

Let tern(a,b) return x where f(x) = maximum

Let m1 = a+(b-a)/3,
m2 = a+(b-a)*2/3

tern(a,b) = { if |f(a)-f(b)|&lt;epsilon    (a+b)/2 
            { if f(a) &lt; f(b)             tern(m1,b)
            { else                       tern(a,m2)
</pre>

<hr><h3>Code</h3>

<pre class="prettyprint linenums ">
public double tern(double a,double b){
    if(Math.abs(f(a)-f(b))&lt;0.0001){
        return (a+b)/2.0;
    }
    double m1 = a+(b-a)/3.0;
    double m2 = a+(b-a)*2/3;
    if(f(a)&lt;f(b)){
        return tern(m1,b);
    }else {
        return tern(a,m2);
    }
}
</pre>
</section><h1>Depth First Search</h1><section><h2>Introduction</h2>

<p><strong>Prerequisites</strong>: <a href="./Recursion" target="_blank">Recursion</a>, <a href="./Stack" target="_blank">Stack</a></p>

<p>A depth first search on a tree is a traversal of a tree that goes as far down as a branch as possible and then back.</p>

<p>A DFS can also be used on a graph to transverse it by ignoring nodes that have already been visited.</p>

<p>A DFS requires a stack but most the time DFS is implemented with recursion which uses the system stack. So most of the time you do not need an explicit stack.</p>

<p><img src="./public_html/img/uploads/dfs.png"></p>

</section><section><h2>Implementation</h2>

<p>Most of the time, DFS is implemented using recursion and it is very short and simple to code.</p>

<pre class="prettyprint linenums ">

public class Tree {
    int value;
    Tree left;
    Tree right;
}
</pre>

<hr><h3>Binary Tree Transversal</h3>

<p><img src="./public_html/img/uploads/dfs.png"></p>

<p>Implementation for outputting a binary tree in order from left to right using DFS</p>

<pre class="prettyprint linenums ">
/**
 * Performs a DFS on a binary tree
 * tree - current tree DFS is at
 */
public static void DFS(Tree cur){
    if(cur==null)return;
    DFS(cur.left);
    System.out.println(cur.value);
    DFS(cur.right);
}
</pre>

<hr><h3>Binary Tree Preorder</h3>

<p><img src="./public_html/img/uploads/dfs-preorder.png"></p>

<p>Implementation for outputting a binary tree in DFS pre order</p>

<pre class="prettyprint linenums ">
/**
 * Performs a DFS on a binary tree
 * tree - current tree DFS is at
 */
public static void DFS(Tree cur){
    if(cur==null)return;
    System.out.println(cur.value);
    DFS(cur.left);
    DFS(cur.right);
}
</pre>

<hr><h3>Binary Tree Postorder</h3>

<p><img src="./public_html/img/uploads/dfs-postorder.png"></p>

<p>Implementation for outputting a binary tree in DFS post order</p>

<pre class="prettyprint linenums ">
/**
 * Performs a DFS on a binary tree
 * tree - current tree DFS is at
 */
public static void DFS(Tree cur){
    if(cur==null)return;
    DFS(cur.left);
    DFS(cur.right);
    System.out.println(cur.value);
}
</pre>

<hr><h3>Graph Transversal</h3>

<p>This is a DFS implementation for traversing a bidirectional graph with positive weights.</p>

<pre class="prettyprint linenums ">
/**
 * Performs a DFS on a graph
 * adjMatrix - Adjacency matrix for a graph with positive edges. 0 indicates no edge.
 * cur - Current node the DFS is at
 * visited - Mutable array which keeps track of which nodes have been visited already
 */
public static void DFS_graph(int[][] adjMatrix,int cur,boolean[] visited){
    if(visited[cur])return;
    visited[cur] = true;
    System.out.println(cur);
    for(int i=0;i&lt;adjMatrix.length;i++){
        if(adjMatrix[cur][i]&gt;0)DFS_graph(adjMatrix,i,visited);
    }
    return;
}

</pre>

</section><section><h2>Memory</h2>

<p>Since DFS goes as deep as possible before going back, the stack we use will need to store at least the depth of the tree.</p>

</section><section><h2>Exercises</h2>

<ol>
<li>Given a binary tree, find the height of it (the longest path from root to leaf)</li>
<li>Given a graph, determine if it contains a cycle.</li>
<li>Given a node and a binary tree, find the next node for post order, pre order and normal order.</li>
</ol>
</section><h1>Breadth First Search</h1><section><h2>Introduction</h2>

<p><strong>Prerequisites</strong>: <a href="./Recursion" target="_blank">Recursion</a>, <a href="./Queue" target="_blank">Queue</a></p>

<p>A breadth first search is a search that transverses level by level. For example in a tree, it will transverse everything from the first layer, to the second layer, the third layer and all the way down to the last layer. BFS is implemented with a queue.</p>

<ol>
<li>Push root into queue</li>
<li>Pop element from queue and push all non visited neighbours</li>
<li>Repeat 2 until queue is empty</li>
</ol>

<p><img src="./public_html/img/uploads/bfs.png"></p>

</section><section><h2>Implementation</h2>

<p>Printing a binary tree using BFS:</p>

<pre class="prettyprint linenums ">
void bfs(Node root){
    Queue&lt;Node&gt; q = new Queue&lt;Node&gt;();
    q.push(root);
    while(q.isEmpty()==false){
        Node cur = q.pop();
        System.out.println(cur.value);
        if(cur.left)q.push(cur.left);
        if(cur.right)q.push(cur.right);
    }
}
</pre>

</section><section><h2>Exercises</h2>

<ol>
<li>Given a grid of squares with walls at certain locations and two locations A and B, find the minimum distance (going up/left/right/down) between the locations or impossible otherwise. For example if A is at (1,1) and B is at (3,1) but there is a wall at (2,1) then the minimum distance would be 4 (down, left, left, up). </li>
<li>Given a tree of letters (A is the root), output the tree using BFS with separators between levels

<ul>
<li>Example: A-&gt;B, B-&gt;D,B-&gt;C, C-&gt;G will output A | B | C D | G </li>
</ul></li>
<li>Given a tree of letters, and two letters X and Y determine if X is an ancestor of Y or Y is a ancestor of X or neither. An ancestor of a node is another node that is the root of a subtree that contains that node. Or simply parent of the node, grand parent, great grandparents etc.

<ul>
<li>Example: A-&gt;B, B-&gt;C, B-&gt;D, D-&gt;G,  A is a parent of both C and D but G and C are not ancestors of each other</li>
</ul></li>
<li>Given a binary tree and a node in the binary tree, find the next node in BFS order of the tree.</li>
</ol>
</section><h1>Flood Fill</h1><section><h2>Introduction</h2>

<p><strong>Prerequisites</strong>: <a href="./Depth_First_Search" target="_blank">Depth First Search</a>, <a href="./Breadth_First_Search" target="_blank">Breadth First Search</a></p>

<p>Flood fill is a search that fills a grid from a start point to find the areas connected to the start point. For example the "bucket fill" in Photoshop or MS Paint uses flood fill to fill in the connecting areas with the same colour.</p>

<p>Flood fill can be implemented using a BFS or DFS.</p>

<p><img src="./public_html/img/uploads/floodfill.png"></p>

</section><section><h2>General solution</h2>

<p>Most flood fill solutions follow the same basic layout. There is a general <a href="./Depth_First_Search" target="_blank">DFS</a> solution and a general <a href="./Breadth_First_Search" target="_blank">BFS</a> solution.</p>

<hr><h3>General DFS</h3>

<pre class="prettyprint linenums ">
//marked is initially a n by m boolean array of false
void floodFill(int i,int j){
   if(outOfBounds(i,j))return;
   if(visited(i,j))return;
   markVisited(i,j);
   floodFill(i+1,j);
   floodFill(i,j+1);
   floodFill(i-1,j);
   floodFill(i,j-1);
}
</pre>

<hr><h3>General BFS</h3>

<pre class="prettyprint linenums ">
void floodFill(int i,int j){
   Queue&lt;Point&gt; q;
   q.push(new Point(i,j));
   while(!q.isEmpty()){
      Point cur = q.pop();
      if(outOfBounds(cur))continue;
      if(visited(cur))continue;
      markVisited(cur);
      q.push(new Point(cur.x+1,cur.y));
      q.push(new Point(cur.x-1,cur.y));
      q.push(new Point(cur.x,cur.y+1));
      q.push(new Point(cur.x,cur.y-1));
   }
   
}
</pre>

</section><section><h2>Bucket Fill</h2>

<p>Given an n x m matrix and a start point and two colors (src and dst), we want to replace all the cells in the matrix that are connected to the start point with the color src and change to color dst as well as output the number of cells changed.</p>

<p>Example:</p>

<p><img src="./public_html/img/uploads/bucket.png"></p>

<p><img src="./public_html/img/uploads/bucket2.png"></p>

<p>In a numeric representation of the colors:</p>

<p><img src="./public_html/img/uploads/bucket3.png"></p>

<p><img src="./public_html/img/uploads/bucket4.png"></p>

<hr><h3>DFS Solution</h3>

<p>This is the <a href="./Depth_First_Search" target="_blank">DFS</a> approach to the problem.</p>

<ul>
<li>Assume that n,m are global integers that are the width and height of the image</li>
<li>Assume that image is a global integer n by m matrix for the image</li>
<li>Assume that visited is a global boolean n by m matrix that is initially all false</li>
</ul>

<pre class="prettyprint linenums ">
/* Changes all pixels that are equal to src to tar that are connected to start
 * and returns the number of pixels changed
 */
public int FloodFillDFS(int x,int y,int src,int tar){
    if(x&lt;0 || x&gt;=n || y&lt;0 || y&gt;=m)return 0;
    if(visited[x][y])return 0;
    visited[x][y] = true;
    if(image[x][y]!=src)return 0;
    image[x][y] = tar;
    int sum = 0;
    sum+=FloodFillDFS(x+1,y,src,tar);
    sum+=FloodFillDFS(x-1,y,src,tar);
    sum+=FloodFillDFS(x,y+1,src,tar);
    sum+=FloodFillDFS(x,y-1,src,tar);
    return sum;
}

floodFillDFS(1,1,1,2);
</pre>

<hr><h3>BFS Solution</h3>

<p>This is the <a href="./Breadth_First_Search" target="_blank">BFS</a> approach to the problem.</p>

<ul>
<li>Assume that n,m are global integers that are the width and height of the image</li>
<li>Assume that image is a global integer n by m matrix for the image</li>
<li>Assume that visited is a global boolean n by m matrix that is initially all false</li>
</ul>

<pre class="prettyprint linenums ">
/* Changes all pixels that are equal to src to tar that are connected to start
 * and returns the number of pixels changes 
 */
public int FloodFillBFS(int x,int y,int src,int tar){
    LinkedList&lt;Point&gt; q = new LinkedList&lt;Point&gt;();
    q.push(new Point(x,y));
    int total = 0;
    while(q.isEmpty()==false){
        Point cur = q.pop();
        if(cur.x&lt;0||cur.x&gt;=n||cur.y&lt;0||cur.y&gt;=m)continue;
        if(visited[cur.x][cur.y])continue;
                visited[cur.x][cur.y] = true;
        if(image[cur.x][cur.y]!=src)continue;
        image[cur.x][cur.y] = tar;
        total++;
        q.push(new Point(cur.x+1,cur.y));
        q.push(new Point(cur.x-1,cur.y));
        q.push(new Point(cur.x,cur.y+1));
        q.push(new Point(cur.x,cur.y-1));
    }
    return total;
}
FloodFillBFS(1,1,1,2);
</pre>

</section><section><h2>Exercises</h2>

<ol>
<li>Given a grid and list of start points and walls, find the distance to the closest start point for every non-wall grid space without passing through a wall.</li>
<li>Given a grid and list of cell coordinates, find the perimeter around the cells

<ul>
<li>Example: a single cell has a perimeter of 4, two cells joined side by side have a perimeter of 6</li>
</ul></li>
</ol>
</section><h1>Backtracking</h1><section><h2>Introduction</h2>

<p>Backtracking is a search that find all possible solutions by enumerating on a partial solution. Backtracking can be done using <a href="./Depth_First_Search" target="_blank">DFS</a> or <a href="./Breadth_First_Search" target="_blank">BFS</a>. Generally, DFS will be better than BFS because backtracking is used to enumerate a large amount of solution. Since BFS requires storing each "level" of solutions and DFS requires storing each "height" of the solution.</p>

<p>Backtracking is similar to recursion, but instead of generating all the solutions, we will generate each solution one by one. In this way, we only need to store the current solution in memory whereas in normal recursion we need to store all the solutions into memory.</p>

<p>Since backtracking requires enumerating through all solutions, it is usually slow with runtimes usually O(n!) or O(2<sup>n</sup>).</p>

</section><section><h2>General Solution</h2>

<pre class="prettyprint linenums lang-html">
Base case:
When a solution has been generated

Reject:
Check if partial solution needs to be rejected

Recurrence:
Generate next partial solution thats growing to full solution

----------

backtrack(solution):
    if reject(solution)
        stop

    if base case
       stop

    backtrack( next_solution ) for next_solution from solution


----------

Initial:
backtrack( empty_solution)

</pre>

</section><section><h2>List all sets</h2>

<p>Given a set of numbers S of length N, output all subsets of S.</p>

<p>For example S=[1,2,3,4]. The subsets encodings of [1,2,3,4]:</p>

<ul>
<li>{}</li>
<li>{1}, {2}, {3}, {4}</li>
<li>{1,2}, {1,3}, {1,4}, {2,3}, {2,4}, {3,4}</li>
<li>{1,2,3}, {1,2,4},{1,3,4},{2,3,4}</li>
<li>{1,2,3,4}</li>
</ul>

<p>We want to be able to enumerate all the subsets of S so we need to find a way to encode a subset of an array. We can use a binary number of length N to encode a subset of an array of length N. For example a 1 represents we use a number in the set and a 0 means we don't use a number in the set.</p>

<p>So above:</p>

<ul>
<li>{} = 0000</li>
<li>{1} = 1000</li>
<li>{2} = 0100</li>
<li>{3} = 0010</li>
<li>{4} = 0001</li>
<li>{1,2} = 1100</li>
<li>{1,3} = 1010</li>
<li>{1,4} = 1001</li>
<li>{2,3} = 0110</li>
<li>{2,4} = 0101</li>
<li>{3,4} = 0011</li>
<li>{1,2,3} = 1110</li>
<li>{1,2,4} = 1101</li>
<li>{1,3,4} = 1011</li>
<li>{2,3,4} = 0111</li>
<li>{1,2,3,4} = 1111</li>
</ul>

<p>At each position we either take or don't take the number in the set and we can do this for each number. We can enumerate through all these encoding by first starting with 0 or 1 and appending more 0's or 1's.</p>

<hr><h3>Recursive Method</h3>

<p>Here is the way we would do this problem with recursion:</p>

<pre class="prettyprint linenums lang-html">
Start with []
Add 1 and 0 to the right of each binary number in the array
Repeat until N
[0,1]
[00,01,10,11]
[000,001,010,011,100,101,110,111]
[0000,0001,0010,0011,0100,0101,0110,0111,1000,1001,1010,1011,1100,1101,1110,1111]
Let S be an array of N integers
Let subsets(arr,n) be subsets of S from 1 to n
 
Base case
S(set,0) = set
 
Recurrence
S(set,n) = subsets([sub+0 for sub in set] + [sub+1 for sub in set],n)
 
Example
 
subsets([],4)
subsets([0,1],3)
subsets([00,01,10,11],2)
subsets([000,001,010,011,100,101,110,111],1)
subsets([0000,0001,0010,0011,0100,0101,0110,0111,1000,1001,1010,1011,1100,1101,1110,1111],0)
=
[0000,0001,0010,0011,0100,0101,0110,0111,1000,1001,1010,1011,1100,1101,1110,1111]
 </pre>

<p>Here is the way we would do this problem with backtracking, however it takes a lot of memory to store <strong>ALL</strong> the solutions. Instead of building all the solutions, we can build each solution one by one.</p>

<p><img src="./public_html/img/uploads/enumerate-sets.png"></p>

<hr><h3>Formalization</h3>

<pre class="prettyprint linenums ">
Base case
subset(0, binary): print binary
 
Recurrence
subset(n-1,binary+'0')
subset(n-1,binary+'1')
 
Example
subset(4,'')
 
subset(3,'0')
subset(3,'1')
 
subset(2,'00')
subset(2,'01')
subset(2,'10')
subset(2,'11')
 
subset(1,'000')
subset(1,'001')
subset(1,'010')
subset(1,'011')
subset(1,'100')
subset(1,'101')
subset(1,'110')
subset(1,'111')
 
subset(0,'0000')
subset(0,'0001')
subset(0,'0010')
subset(0,'0011')
subset(0,'0100')
subset(0,'0101')
subset(0,'0110')
subset(0,'0111')
subset(0,'1000')
subset(0,'1001')
subset(0,'1010')
subset(0,'1011')
subset(0,'1100')
subset(0,'1101')
subset(0,'1110')
subset(0,'1111')
</pre>

<hr><h3>Implementation</h3>

<pre class="prettyprint linenums ">
void subsets(int arr[],bool use[],int i){
    if(i&gt;=arr.length){
         for(int j=0;j&lt;n;j++){
              System.out.print("%d ",arr[i]);
         }
         System.out.println();
         return;
     }
     use[i] = false;
     subsets(arr,use,i+1);
     use[i] = true;
     subsets(arr,use,i+1);
}
subsets([1,2,3,4],[0,0,0],0);
 
subsets([1,2,3,4],[0,0,0],0);
 
subsets([1,2,3,4],[1,0,0],0);
</pre>

</section><section><h2><a href="./Permutation" target="_blank">Permutation</a></h2>

<p>Permutation can be</p>

</section><section><h2><a href="./N_Queen_Problem" target="_blank">N Queen Problem</a></h2>

<p>Find the number of ways to place N queens on a NxN board without any of them attacking each other. Queens attack each other by being along the same row, column or diagonal.</p>

<p><img src="./public_html/img/uploads/nqueen.jpg"></p>

<p>First we need to be able to encode a solution. There must be only one queen in each row, each column, each positive diagonal and each negative diagonal. We need a way to encode each row, column and diagonal to make it easy to check that they are all unique.</p>

<p><img src="./public_html/img/uploads/nqueen3.png"></p>

<p>If we guarantee that all rows are unique and we have all columns filled, then we can guarantee that all the columns are unique as well.</p>

<p>To encode a diagonal we can use a clever equation to represent the diagonal. We can notice that every positive diagonal has the same value with row+col.</p>

<p>d1 = row+column</p>

<p>N=6:</p>

<p><img src="./public_html/img/uploads/nqueen1.png"></p>

<p>Every square with the same d1 is in the same diagonal ( / ). For example on a 6x6 board: (0,2), (1,1), (2,0) all have d1 = 2 and are all along the same diagonal.</p>

<p>We can also notice that every negative diagonal has the same value of (N-row)+column. The second diagonal can also be found using another equation:</p>

<p>d2 = (N-row-1)+column</p>

<p>N=6:</p>

<p><img src="./public_html/img/uploads/nqueen2.png"></p>

<p>Everything with the same d2 will be on the same diagonal. For example on a 6x6 board (0,0),(1,1),(2,2) have d2 = 5 and are all along the same diagonal.</p>

<p>Now that we get can encode rows, columns, and diagonals, we can use it to make checking solutions more easy. We can keep sets that track with rows/columns/diagonals are currently filled and check our solution to make sure we do not have anything in the same row/column/diagonal.</p>

<p>We can place a queen in each row and make sure that each column / diagonals is unfilled.</p>

<hr><h3>Formalization</h3>

<pre class="prettyprint linenums ">
Let N be a NxN board where we want to place N queens 
Let queen(n,columns,d1,d2) be a placing of N queens across a board
 
Base case
queen(0,cols,d1,d2): print solution

Reject solution
reject(cols,d1,d2):   { false if duplicates in cols or d1 or d2
                               { true otherwise
Recurrence 
queen(row,cols,d1,d2) = queen(row-1,cols with col,d1 with row+col,d2 with N-row+col) for col from 1 to N
 
Examples
N=4
queen(4,[],[],[])

queen(3,[0],[3],[6])   
queen(3,[1],[4],[5])   
queen(3,[2],[5],[4])   
queen(3,[3],[6],[3])  

queen(2,[0,0],[3,2],[6,5]) x-- reject   
queen(2,[0,1],[3,3],[6,4]) x-- reject
queen(2,[0,2],[3,4],[6,3])
queen(2,[0,3],[3,5],[6,2])
queen(2,[1,0],[4,2],[5,5]) x-- reject
queen(2,[1,1],[4,3],[5,4]) x-- reject
queen(2,[1,2],[4,4],[5,3]) x-- reject
queen(2,[1,3],[4,5],[5,2])
queen(2,[2,0],[5,2],[4,5]) 
queen(2,[2,1],[5,3],[4,4]) x-- reject
queen(2,[2,2],[5,4],[4,3]) x-- reject
queen(2,[2,3],[5,5],[4,2]) x-- reject
queen(2,[3,0],[6,2],[3,5])
queen(2,[3,1],[6,3],[3,4]) 
queen(2,[3,2],[6,4],[3,3]) x-- reject
queen(2,[3,3],[6,5],[3,2]) x-- reject

queen(1,[0,2,0],[3,4,1],[6,3,4]) x-- reject
queen(1,[0,2,1],[3,4,2],[6,3,3]) x-- reject
queen(1,[0,2,2],[3,4,3],[6,3,2]) x-- reject
queen(1,[0,2,3],[3,4,4],[6,3,1]) x-- reject
queen(1,[0,3,0],[3,5,1],[6,2,4]) x-- reject
queen(1,[0,3,1],[3,5,2],[6,2,3])
queen(1,[0,3,2],[3,5,3],[6,2,2]) x-- reject
queen(1,[0,3,3],[3,5,4],[6,2,1]) x-- reject
queen(1,[1,3,0],[4,5,1],[5,2,4])
queen(1,[1,3,1],[4,5,2],[5,2,3]) x-- reject
queen(1,[1,3,2],[4,5,3],[5,2,2]) x-- reject
queen(1,[1,3,3],[4,5,4],[5,2,1]) x-- reject
queen(1,[2,0,0],[5,2,1],[4,5,4]) x-- reject
queen(1,[2,0,1],[5,2,2],[4,5,3]) x-- reject
queen(1,[2,0,2],[5,2,3],[4,5,2]) x-- reject
queen(1,[2,0,3],[5,2,4],[4,5,1])
queen(1,[3,0,0],[6,2,1],[3,5,4]) x-- reject
queen(1,[3,0,1],[6,2,2],[3,5,3]) x-- reject
queen(1,[3,0,2],[6,2,3],[3,5,2]) 
queen(1,[3,0,3],[6,2,4],[3,5,1]) x-- reject
queen(1,[3,1,0],[6,3,1],[3,4,4]) x-- reject
queen(1,[3,1,1],[6,3,2],[3,4,3]) x-- reject
queen(1,[3,1,2],[6,3,3],[3,4,2]) x-- reject
queen(1,[3,1,3],[6,3,4],[3,4,1]) x-- reject

queen(0,[0,3,1,0],[3,5,2,0],[6,2,3,3]) x-- reject
queen(0,[0,3,1,1],[3,5,2,1],[6,2,3,2]) x-- reject
queen(0,[0,3,1,2],[3,5,2,2],[6,2,3,1]) x-- reject
queen(0,[0,3,1,3],[3,5,2,3],[6,2,3,0]) x-- reject
queen(0,[1,3,0,0],[4,5,1,0],[5,2,4,3]) x-- reject
queen(0,[1,3,0,1],[4,5,1,1],[5,2,4,2]) x-- reject
queen(0,[1,3,0,2],[4,5,1,2],[5,2,4,1]) SOLUTION
queen(0,[1,3,0,3],[4,5,1,3],[5,2,4,0]) x-- reject
queen(0,[2,0,3,0],[5,2,4,0],[4,5,1,3]) x-- reject
queen(0,[2,0,3,1],[5,2,4,1],[4,5,1,2]) SOLUTION
queen(0,[2,0,3,2],[5,2,4,2],[4,5,1,1]) x-- reject
queen(0,[2,0,3,3],[5,2,4,3],[4,5,1,0]) x-- reject
queen(0,[3,0,2,0],[6,2,3,0],[3,5,2,3]) x-- reject
queen(0,[3,0,2,1],[6,2,3,1],[3,5,2,2]) x-- reject
queen(0,[3,0,2,2],[6,2,3,2],[3,5,2,1]) x-- reject
queen(0,[3,0,2,3],[6,2,3,3],[3,5,2,0]) x-- reject
</pre>

</section><section><h2>Exercises</h2>

<ol>
<li>Given a sequence of numbers, output all increasing subsequences</li>
<li>Given a NxN chessboard with certain squares that can have no pieces placed, output the number of configurations that can be made from rooks without attacking each other.</li>
<li>Given a sudoku grid, output a solution for the grid if it exists. Note: this question is popular for technical interviews.</li>
</ol>
</section><h0>Dynamic Programming</h0><section><h3>Introduction</h3>

<p><strong>Prerequisites</strong>: <a href="./Advanced_Recursion" target="_blank">Advanced Recursion</a></p>

<p><strong>Next</strong>: <a href="./Advanced_Dynamic_Programming" target="_blank">Advanced Dynamic Programming</a></p>

<p>Dynamic programming uses memoization by solving subproblems to solve the more complex problem. Dynamic programming uses recursion but instead of working backwards, it builds up the answer and reduces the number of duplicate computations.</p>

<p>Like <a href="./Recursion" target="_blank">recursion</a>, dynamic programming requires two things:</p>

<ul>
<li>A base case and</li>
<li>A subproblem that can be reduced into smaller subproblems </li>
</ul>

</section><h1>Advanced Dynamic Programming</h1><section><h2>Introduction</h2>

<p>Dynamic programming is very powerful and more efficient than recursion for problems that recompute multiple values. However sometimes it is difficult to find an efficient dynamic programming solution and we will examine problems where we will need higher dimensions.</p>

<hr><h3>Prerequistes</h3>

<ul>
<li><a href="./Dynamic_Programming" target="_blank">Dynamic Programming</a></li>
</ul>

</section><section><h2><a href="./Longest_Common_Subsequence" target="_blank">Longest Common Subsequence</a></h2>

<p>A subsequence is a subset of the original sequence that is in the same order. For example in the string "abcdefghi", "aeg" is a subsequence but "eaq" is not because it is not in order.</p>

<p>The longest common subsequence between two strings A and B is the longest subsequence in A that is also in B.</p>

<p>For example given A="xyaaaabcdeg", B="bcaaaaefgxy" the longest common subsequence is "aaaaeg"</p>

<pre class="prettyprint linenums lang-html">
xyaaaabcde_g
bcaaaa___efgxy
</pre>

<p>If we try to use greedy we will see it doesn't work. For example if we use try to take as much as B as we can, we see that we will get BCEG or if we try to take as much as A we get XY.</p>

<p>Let first write a formal definition of the problem, given two strings A and B each with lengths N and M respectively we want to find the longest common subsequence between them.</p>

<p><strong>[Note to make reading easier I have used short forms for substring and index. For example A[3] means the 3rd character of A and A[1..4] means the substring of A from the first character to the fourth character inclusive. A[0] represents the null substring of A]</strong></p>

<p>The base is simple. The LCS of A[1..x] (where x is from 1 to N) and B[0] = 0. The LCS of B[1..x] and A[0] = 0.</p>

<p>We need to break this problem into subproblems.</p>

<p>If A[N] = B[M] and then the new LCS is the LCS of A[1..N-1] and B[1..M-1]. Note that if two strings have the same character at the end of their string it has to be part of the LCS. Try to prove this to yourself.</p>

<pre class="prettyprint linenums lang-html">
LCS of matched = (LCS of A from 1 to N-1, B from 1 to M-1) + A[N]
</pre>

<p>If A[N] != B[M] then we try to match A[N] with B[M-1] or A[N-1] with B[M]. Thus we take the LCS of A[1..N-1] and B[1..M] and the LCS of A[1..N] and B[1..M-1].</p>

<pre class="prettyprint linenums lang-html">
LCS of not matched = max ( (LCS of A[1..N], B[1..M-1]) , (LCS of A[1..N-1],B[1..M]))
</pre>

<p>Putting it all together we have:</p>

<pre class="prettyprint linenums lang-html">
Let LCS[i][j] be the length of longest common subsequence of A[1..i] and B[1..j] where 0&lt; i ≤ n and 0 &lt; j ≤ m.

Base case:
LCS[i][0] = 0 where 0&lt; i ≤ n
LCS[0][j] = 0 where 0&lt; j ≤ m

Subproblem:
if A[i] == B[j], LCS[i][j] = LCS[i-1][j-1]+1 where 0&lt; i ≤ n and 0 &lt; j ≤ m
if A[i] != B[j], LCS[i][j] = max( LCS[i-1][j], LCS[i][j-1] ) where 0&lt; i ≤ n and 0 &lt; j ≤ m
</pre>

</section><section><h2><a href="./Zero-one_Knapsack_Problem" target="_blank">Zero-one Knapsack Problem</a></h2>

<p>In the <a href="./Dynamic_Programming" target="_blank">Dynamic Programming</a> section, we examined the knapsack problem:</p>

<p>Given an unlimited amount of N items with positive weights and values, we want to find the maximum value we can hold with a capacity.</p>

<p>Let's change the problem slightly such that there is only one of each object. The problem becomes slightly more difficult because we to take into account whether or not we have used an object before.</p>

<p>Given one of each N items with positive weights and values, we want to find the maximum value we can hold with a capacity W.</p>

<pre class="prettyprint linenums ">
Let knapsack(N,W) be the maximum value of iterating through N items with a maximum capacity of W
Let weights be an array of weights
Let values be an array of values

knapsack(i,0) = 0
knapsack(i,w) = 0 if no items can fit
knapsack(i,w) = 0 where i &lt;= 0

knapsack(n,w) = max(knapsack(n-1,w-weight[n])+value[n], knapsack(n-1,w))
</pre>

<pre class="prettyprint linenums ">
Let knapsack[N][W] be the maximum value of iterating through N items with maximum capacity of W
Let weights be an array of weights where weights[i] is the weight of the ith item
Let values be an array of values where values[i] is the value of the ith item

for i from 0 to W
    knapsack[0][i] = 0

for n from 1 to N
    knapsack[n][0] = 0
    for w from 1 to W
        knapsack[n][w] = max(knapsack[n-1][w-weight[n]]+value[n], knapsack[n-1][w])
</pre>
</section><h1>Coin Problem</h1><section><h2>Introduction</h2>

<p>Let's say that you wanted to make change for $51 using the smallest amount of bills ($1, $2, $5, $10, $20). We can use a greedy approach by always taking the highest bill that can be subtracted to find the smallest amount of change. 51 - 20 = 31 - 20 = 11 - 10 = 1. So the smallest amount of change would be comprised of 2 x $20 + 1 x $10 + 1 for a total of 5 bills. This solution seems very easy to implement, but what if the bills were not so nice?</p>

<p>Imagine that an alien currency was in denominations of $3, $5, $7 and $11. What would be the smallest amount of bills to make change for $13? Note that a greedy approach does not work for this alien currency. For example: 13 - 11 = 2. It is impossible to make change using the greedy approach.</p>

</section><section><h2>Solution</h2>

<p>Let's define the problem more formally: Given a list of bills each with a positive denomination d, find the lowest amount of bills required to make C dollars or return impossible if it cannot be done.</p>

<p>The base case 0 for this is very simple. There are 0 bills to make 0 dollars.</p>

<p>We can reduce this problem into subproblems. Let's assume that we have found out the lowest amount of bills required to make all the dollar amounts from 0 to C-1 or determined if it is impossible to do so. Lets take a look at an arbitrary bill b with denomination d. We know the minimum number of bills to make C-d (or if its impossible) based on our assumption that we have solved from 0 to C-1. Thus if use the bill b to make C then it is just the minimum number of bills to make C-d with 1 more bill so we add 1 more to that value. If we take the minimum value for all bills (if its possible to make C-d), we will get the lowest amount of bills required to make C.</p>

<p>Putting it all together:</p>

<pre class="prettyprint linenums lang-html">
Let bills[C] be the smallest amount of bills to make the amount C, or impossible if it is not possible

Base case:
bills[0] = 0

Subproblem:
bills[C] = min(bills[C-d]+1) for all bills where d is the denominator of the bill and bills[C-d] is not impossible
if bill[C-d] = impossible for all bills, then bills[C] is impossible
</pre>

<p>Example of previous problem where the bills are ($3, $5, $7, $11) and we want to find the minimum number of bills to make 13.</p>

<p>Let -1 be "impossible".</p>

<table>
<thead>
<tr>
  <th>C</th>
  <th>0</th>
  <th>1</th>
  <th>2</th>
  <th>3</th>
  <th>4</th>
  <th>5</th>
  <th>6</th>
  <th>7</th>
  <th>8</th>
  <th>9</th>
  <th>10</th>
  <th>11</th>
  <th>12</th>
  <th>13</th>
</tr>
</thead>
<tbody>
<tr>
  <td>bills[C]</td>
  <td>0</td>
  <td>-1</td>
  <td>-1</td>
  <td>1</td>
  <td>0</td>
  <td>1</td>
  <td>2</td>
  <td>-1</td>
  <td>2</td>
  <td>3</td>
  <td>2</td>
  <td>1</td>
  <td>4</td>
  <td>3</td>
</tr>
</tbody>
</table>

</section><section><h2>Implementation</h2>

</section><section><h2>Exercises</h2>

<ol>
<li>Given a list of bills each with unique denomination d, find the number of ways to make C dollars. 

<ul>
<li>For example given bills: $2, $3, $5, there are 2 ways to make $7 (2+5, 2+2+3)</li>
</ul></li>
<li>Given a list of N integers, separate the list into two sets such that the difference is minimized and output the difference.

<ul>
<li>For example given integers: 1, 4, 10, 12, we can separate them into (4+10=14) and (1+12=13) so the minimum difference is 1.</li>
</ul></li>
<li>Given a list of lengths, find the smallest area that can be created if  the lengths are used to make a triangle. 

<ul>
<li>For example, given lengths: 2,4,6,8,10 we can make a triangle with minimum area 43.3 if we use the sides (2+8=10, 4+6 = 10, 10).</li>
</ul></li>
</ol>
</section><h1>Knapsack Problem</h1><section><h2>Introduction</h2>

<p>Imagine you are a robber and you have found a large stash of valuables. Each valuable has a value and a weight. You can only hold 10kg in your bag and you want to find the highest valued haul you can get away with.</p>

<ul>
<li>Necklace: $10, 1kg</li>
<li>Stack of cash: $270, 3kg</li>
<li>Jewelry: $665, 7kg</li>
<li>Rare painting: $900, 9kg</li>
</ul>

<p>Let's try a greedy approach: we will take the items with the highest value to weight ratio.</p>

<ul>
<li>Necklace: $10/kg</li>
<li>Stack of cash: $90/kg</li>
<li>Jewelry: $95/kg</li>
<li>Rare painting: $100/kg</li>
</ul>

<p>The greedy approach will choose the rare painting and the necklace for a total of $910. However if we take the jewelry and the stack of cash we will get $935 and still fit it into the bag. How can we solve this problem? The answer is dynamic programming.</p>

</section><section><h2>Solution</h2>

<p>Let's first write a more formal definition of the problem:</p>

<p>Given n objects, each associated with a positive weight and value, and a maximum total weight W that we can hold, what is the maximum value we can hold. In the zero/one knapsack problem, there is only one of each object so we either take it or leave it.</p>

<p>Let's write a more specific version of the problem: we want to find the maximum value that a bag with maximum weight W can hold of N objects with positive weight and value which we can either take or not take.</p>

<p>The base case for this is trivial. With zero weight, the maximum value you can have is 0.</p>

<p>We now have to break this problem down into subproblems.</p>

<p>Now we want to find the maximum value for a bag of maximum weight W and assessing all N objects. Since we have already assessed up to N-1 objects we only need to assess the Nth object. For the Nth object we can either take it or leave it.</p>

<p>If we leave it, then it is the same as a bag of maximum weight W with N-1 objects because we are just ignoring the Nth object.</p>

<pre class="prettyprint linenums lang-html"> max value leaving = maximum value of N-1 objects with weight W
</pre>

<p>If we take it, then we need to find the maximum value thats possible while making room for that object and add that to the value of the object.</p>

<pre class="prettyprint linenums lang-html">max value taking = (maximum value of N-1 objects seen with weight W-weight of object N) + value of object N. 
</pre>

<p>If we want the maximum value of assessing N objects and maximum weight W then we want the max of leaving the Nth object and taking the Nth object so:</p>

<pre class="prettyprint linenums lang-html">
max value = max( maximum value taking, maximum value leaving)
max value = max( maximum value of N-1 objects with weight W, (maximum value of N-1 objects with weight W - weight of N) + value of N))
</pre>

<p>Putting it all together we have:</p>

<pre class="prettyprint linenums lang-html">
Let weight[i] be the weight of object i
Let value[i] be the value of object i

Let knapsack[i][j] be the maximum value that a knapsack of maximum weight j can hold with objects seen from 1 to i

Base case:
knapsack[0][0] = 0

Subproblem:
knapsack[i][j] = max(knapsack[i-1][j-weight[i]], knapsack[i-1][j-1])
</pre>

</section><section><h2>Implementation</h2>

</section><section><h2>Exercises</h2>

<ol>
<li>Given a list of n objects with a positive weight and value, find the maximum value that can be obtained with maximum weight W. However, each object can be used more than once.</li>
</ol>
</section><h0>Strings</h0><section><h3>Introduction</h3>

<p>String problems are more important than ever before with the enormous amount of text and information that is now available. For example, if we search for keywords on Google out of the millions of articles, how can we do it in such a way that the retrieval is relevant, accurate and efficient? If we misspell the word "shooting" as "sohoting" how can we come up with a list of autocorrected words?</p>

</section><h1>Pattern Matching</h1><section><h2>Introduction</h2>

<p>Pattern matching is finding if a certain sequence of elements exists in another larger sequence of elements. For example we want to find if the string "abc" is in the string "abdabdbdacbaabcasd" (which the answer is yes).</p>

</section><section><h2><a href="./Knuth_Morris_Pratt" target="_blank">Knuth Morris Pratt</a></h2>

<p>If we have the needle string "abcxabcy" and haystack string "abcyabcxabcy" then our first search will be putting the needle at position 0 as we see the search fails at 'x'. However we note that we do not need to set the needle at position 1 because we have already done the search for the prefix "abc". Thus we can search starting by setting the needle at the next 'a'.</p>

<p>KMP uses this type of optimization for pattern matching by precomputing a table for the needle string.</p>

</section><section><h2><a href="./Rabin_Karp" target="_blank">Rabin Karp</a></h2>

</section><section><h2><a href="./Finite_State_Automata" target="_blank">Finite State Automata</a></h2>

</section><section><h2><a href="./Boyer_Moore" target="_blank">Boyer Moore</a></h2>
</section>